### 基础理解

##### vim插件结构目录

- 在vim安装目录下同样有一套插件目录，在自己配置的环境下同样有一套，作用是一样的，一般安装目录/usr/share/vim，自己配置的目录在~/.vim

###### autoload

- 随着对Vim的深度定制，Vim初始化时所加载的插件越来越多，其中可能包含一些大型插件，导致Vim初始化非常耗时。autoload的目的就是尽量延迟插件的加载。

- 引用autoload目录下的插件时，需要提供文件路径、文件名和函数名，并用’#’连接它们。例如，autoload目录下有一个插件名为bar.vim，bar.vim中定义了函数test()，要通过如下方式调用test函数：

   ```text
   :call bar#test()
   ```

- 如果，bar.vim插件存放在autoload子目录foo下，也就是autoload/foo/bar.vim，为了调用test()函数，需要如下使用如下格式：

   ```text
   :call foo#bar#test()
   ```

- 引用autoload目录下插件中的全局变量使用同样的方式。

- vim-plug下载到autoload目录下，call plug#begin()    call plug#end()就是这个道理

###### plugin

- 此目录下的插件在启动vim时会自动加载
- vim-plug默认的插件安装目录~/.vim/plugged，并不是plugin，vim-plug插件会自己控制插件的安装与加载，并不需要vim本身去加载了，所以换了一个文件，有vim-plug来控制加载。

##### 复制粘贴

- vim下每一个删除剪切操作都会把东西放到剪切板上去
- y0,复制到当前行开始 y$,复制到当前行结束 yfn，复制到第一个n结束的位置
- vim中的剪切板和系统的剪切板是隔开的，如果需要共享，可以设置set clipboard=unnamedplus,此时所有的剪切操作都会到系统剪切板里，如果只是想偶尔复制东西到系统剪切板，"+y可以将选中的东西复制到系统剪切板，如果没有在可视模式下选中，那就是光标所在的当前行。
- vim中的寄存器有很多，类型各不相同，有未命名寄存器，数字寄存器存储的是c、d、x删除的文本，其不断被覆盖，文本寄存器a-z存储的是复制的文本，用"ay来复制到a，"Ay,就是将新复制的添加到a寄存器后面，b类似，要用B添加。粘贴时要指明寄存器"ap

- ```
   autocmd TermOpen term://* startinsert
   autocmd TermEnter term://* startinsert  如果离开重新进入，进入插入模式，
   	此类型语句也可以设置为离开终端缓冲区时进入模式
   ```

   - 其中term://*是neovim下的表示，vim下没有，因为终端缓冲区名称始终以 term:// 开头，这个语句就是匹配终端缓冲区
   - startinsert是一个命令，内置的，表示进去插入模式
   - 所以此自动命令的含义为，在打开创建一个终端缓冲区的时候始终进去插入模式
   - 其中TermOpen可以更换为其他的，但是只有neovim下才有

### 一堆set

- ```
  set number显示行号
  set nonumber取消行号
  ```

- ```
  set ruler 打开标尺选项(ruler option)。将在屏幕右下角，显示当前所在的行和列，以及相对于整个文件所处的位置。
  ```

- ```
  set ignorecase忽略大小写
  set noignorecase重新设置为大小写敏感
  set smartcase
  在设置了ignorecase选项后，我们查找字符串word，则会同时匹配word、Word，WORD等；如果我们查找字符串WORD，匹配的结里也是一样的。但是如果设置了:set ignorecase和:set smartcase两项之后，就会执行不同的匹配模式：如果输入的是小写字符，那么就会匹配各种可能的组合，与ignorecase选项的情况相同；但是如果在输入中有一个大写字符，那么这时就会转变为精确查找，与noignorecase选项的情况相同。
  ```

- ```
  set hlsearch设置高亮显示查找的文本
  set nohlsearch关闭高亮显示
  set incsearch打开自动匹配选项
  set noincsearch关闭自动匹配选项
  set nowrapscan禁止循环查找
  set wrapscan启用循环查找
  ```

- ```
  set colorcolumn=100
  'colorcolumn' 是一个逗号分隔的屏幕列列表，用 ColorColumn |hl-ColorColumn| 突出显示。 用于对齐文本。 会使屏幕重绘变慢。屏幕列可以是一个绝对数字，也可以是一个以'+'或'-'开头的数字，它可以添加到'textwidth'中或从'textwidth'中减去。
  :set cc=+1  " highlight column after 'textwidth'
  :set cc=+1,+2,+3  " highlight three columns after 'textwidth'
  :hi ColorColumn ctermbg=lightgrey guibg=lightgrey
  When 'textwidth' is zero then the items with '-' and '+' are not used.A maximum of 256 columns are highlighted.
  这个设置是让100列以后的文档特殊显示提示你超过你设置的列的大小了
  ```
  
- ```
  set virtualedit=block
  虚拟编辑意味着可以将光标定位在没有实际字符的地方。 这可以在制表符的中间或超出行尾。 对于在可视模式下选择矩形和编辑表格很有用。
  Virtual editing means that the cursor can be positioned where there is no actual character.  This can be halfway into a tab or beyond the end of the line.  Useful for selecting a rectangle in Visual mode and editing a table.
  A comma separated list of these words:
  	block       Allow virtual editing in Visual block mode.
  	insert      Allow virtual editing in Insert mode.
  	all         Allow virtual editing in all modes.
  	onemore     Allow the cursor to move just past the end of the line
  	none        When used as the local value, do not allow virtual
  ```

  

### 一些使用

- 文本以16进制显示和返回以文本显示

  ```
  %!xdd 文本以16进制显示
  %!xdd -r 文本返回以字符显示
  ```

  - %表示当前文件名 ，所以是将当前文件以16进制显示，！是运行外部命令，如果！是第一个字符，例如!xxd %，此时会出现Press ENTER or type command to continue，这时按键之后就会退出显示，但是如果以%开头就表示将当前文件内容替换为执行命令的结果，例如%!ls，这个命令将当前文件的内容改为ls系统命令输出的结果，此时文件内容被改变
  - %前面只能是%，如果我们知道文件名，输入文件名就会出错例如123.md!xdd，此时会报错没有这个命令，所以只能是%

- vim下组合键一般是不区分大小写的，因为区分大小写这个按键会很麻烦，一般在map快捷键是是不分区大小写的例如

  ```
  inoremap <C-A> <ESC>A
  ```

  - 此时按ctrl在按小写的a同样是这个按键映射的功能

  - 但是组合键外面是区分大小写的，例如<LEADER>开始的按键后面在尖括号外面的字母按键是区分大小写的，还有例如

    ```
    CTRL-W T           move current window to a new tab page
    CTRL-W t           go to top window
    ```

    - 其中组合键中的w是不区分大小写的，怎么写都行，组合键外面的是区分的

- mkview命令就是保存当前的窗口，到时候可以使用loadview恢复出来，这样就保存了当前窗口，mkview命令可以带一个文件名，这样就保存到这个文件中，然后loadview恢复的时候就从这个文件里面恢复，如果没有文件名，默认就保存到~/.vim/view中

  - mkview" 的输出包含如下项目: 

  - 该窗口使用的参数列表。如果使用全局参数列表，它被重设为全局列表的值。参数列   表的索引位置也被保存。 

  - 窗口编辑的文件。如果没有文件，该窗口被清空。 

  - 如果 ['viewoptions'](https://yianwillis.github.io/vimcdoc/doc/options.html#'viewoptions') 包含 "options" 或者 "localoptions" 的话，恢复映射、缩写   和局部于窗口的选项。一般，只有局部于当前缓冲区和窗口的选项值被恢复。如果视   图作为会话的一部分被保存，并且 ['sessionoptions'](https://yianwillis.github.io/vimcdoc/doc/options.html#'sessionoptions') 包含 "options" 的话，局部选   项的全局值也被保存。 

  - 如果使用手动折叠并且 ['viewoptions'](https://yianwillis.github.io/vimcdoc/doc/options.html#'viewoptions') 包含 "folds" 的话，恢复折叠。也恢复手动   打开和关闭的折叠。 

  - 滚动条的位置和文件中的光标位置。如果有关闭的折叠，这不能很好的工作。 

  - 本地的当前目录，如果和全局当前目录不同且 ['viewoptions'](https://yianwillis.github.io/vimcdoc/doc/options.html#'viewoptions') 包含 "curdir" 的话。

    ```
    set viewoptions=set viewoptions=cursor,folds,slash,unix
    代表mkview保存的视图恢复的时候的状态，以及一些具体的设置
    ```


##### verbose作用

- verbose在命令行中使用可以检测某个快捷键有没有被映射过，以保证快捷键的唯一映射，否则容易出错

- 在coc.nim配置文件中有这么一句

  ```
  verbose imap <tab>
  
  i  <Tab>       * pumvisible() ? "\<C-N>" : <SNR>2_check_back_space() ? "\<Tab>" : coc#refresh()
          Last set from ~/.vim/vimrc line 251
  ```

  - 此语句可以检测插入模式下tab键有没有被映射，输入这个语句，屏幕上会打印出来vimrc中映射的信息，可以看到在第几行映射的，还可以看到在那个模式下映射的。以此可以看到是不是唯一的映射，还可以看到映射的是什么命令

  - 例如自己定义的快捷键，可以检测

    ```
    verbose noremap ti
    
     ti          * :tabe<CR>
            Last set from ~/.vim/vimrc line 215
    ```

##### 配色方案

- vim下配色方案主要是通过highlight来修改的，我们使用的配色方案就是人家写好的，至于为什么molokai配色方案下可视模式下选中文字没有高亮显示，这是作者的主观意愿，gruvbox配色方案就有这个效果。不满意的话可以通过highlight命令来查看修改。
- vim下配色有dark和light两种背景色，可以通过background选项来设置，两种配色的感觉是不一样的。

### 基础知识

##### 基本编辑

- 使用i命令，将在当前字符的左边新增文本。而使用I命令，则在当前行的开头新增文本
- 使用a命令，可以在当前光标所在的字符后面进入插入状态，而A命令，则是在一行的末尾进入插入状态
- 使用o命令，可以在当前行的下面新增一行并进入插入模式；而使用O命令，则可以在当前行的上一行新增一行并进入插入模式。
- 使用x命令，删除当前字符。也可以使用X命令，删除当前光标前的一个字符。将数字和命令组合则可以一次删除多个字符。例如3x命令，则可以删除3个字符。
- 使用dd命令，可以删除整个当前行。而D命令，则只删除当前光标到本行结尾的所有文字。
- 如果我们想要恢复先前的改动，那么可以使用u命令来撤销上一次的修改；而U命令则将撤销进入当前行以后对该行做的所有修改。当光标离开该行之后，就无法再用此命令恢复在该行的操作了。如果我们想要重做某些工作，那么可以使用CTRL+R命令。
- Vim命令中的前导冒号将使光标移动到屏幕底端最后一行的下面，随后键入的命令也随之显示在屏幕上，按回车键将执行此命令。如果需要取消一个冒号命令，则需要重复按ESC键或CTRL+H，直到光标返回到文档的最后一行。输入：可以输入命令，如果想取消需要按两次ESC或者按组合键CTRL+H

##### 移动

###### 行内移动

- w命令向前移动一个单词，用b命令向后移动一个单词。我们也可以用数字做前缀组成新的命令，来快速的移动。例如4w就是向前移动4个单词，而5b则是向后移动5个单词。
- 命令e也是向前移到一个单词，但是将光标定位在单词的结尾处；命令ge则是向后移到一个单词并到达前一个单词的结尾处。
- 利用$命令可以使光标移到一行的结尾处；而g_命令则会而将光标移到一行的最后一个非空字符处。
- 利用0命令可以使光标移到一行的开始处。而^命令则会忽略开头的空格，而将光标移到一行的第一个字符处。

###### 行间移动

- 进入命令状态，直接输入行号，按下回车键就可以移动到指定的行。

- 使用G命令，可以移动到指定的行。例如3G可以使我们快速的移到第3行。而1G则可以使我们移到文章的最顶端，而G则是定位到文章的最后一行。

- 使用-命令，可以移动到上一行的第一个非空字符处；而+命令，则可以移动到下一行的第一个非空字符处。

- 使用)命令，可以向前移动一个句子；而(命令，则可以向后移动一个句子。

- 使用}命令，可以向前移动一个段落；而{命令，则向后移动一个段落。

- 除了在行间移动，我们还可以使用ctrl+U和ctrl+D命令进行向上和向下翻页，以快速移动到文章的不同部分。

- 执行:jumps命令，就会看到一个曾到过的行的列表。使用命令CTRL-O跳转到移动记录列表中上一个位置。而命令CTRL-I跳转到移动记录列表中下一个位置。你不但可以在当前文件内跳转，甚至还可以移动到曾经涉足过的其它文件。这个CTRL-O可以直接使用，不用先输入jumps

  ![](https://pic2.zhimg.com/80/v2-1c0291d48e3b7d427c1a128742aaa1f5_720w.png)

###### 显示位置信息

- 即使没有显示行号，也可以使用CTRL-G命令在屏幕的下端显示当前所在位置的信息。我们还可以在CTRL-G命令加上一个数字参数，这个数字越大得到的信息就越详细。命令1CTRL-G会显示文件的全路径。命令2CTRL-G会同时显示缓冲区的数字标号。
- 命令gCTRL-G可显示出当前文件中的字符数的信息。主要显示出当前行数（Line）、列数（Col）、字数（Word）、字符数（Char）和字节数（Byte）等信息。

##### 复制和粘贴

- 在Vim中，我们使用寄存器（register)概念进行多次的剪切和粘贴操作。通常编辑器中只有一个剪切板可供使用，而在Vim中最多时可以使用26个剪切板，这样就会大大提高工作的效率。

###### 删除文本的保存

- 当我们使用d或x删除文本时，被删除掉的文本并没有被Vim所丢弃，而是被保存在寄存器之中。我们可以使用p命令来粘贴刚刚所删掉的内容。
- 下面来看看他是如何工作的。首先随意输入几行文本，然后移动到其中的一行，用dd命令来删掉一行。接着将光标移到任意位置，使用p命令，就会在当前光标的下一行粘贴被删除掉的内容。使用x命令删除的东西也可以粘贴回来。所不同的是在当前光标处之后粘贴。有了这样的命令，我们就可以轻松找回刚刚误删除的内容了。可以理解为如果是一行的内容用p命令就是在下一行，如果不是一行的内容就是在当前光标之后粘贴

###### 复制

- 在Vim中使用y命令（yank）进行复制操作。yw命令可以复制一个单词。yy命令可以复制一行。我们也可以使用Y命令来复制一行，或者使用数字做前缀来指定复制多行。使用y$命令，则可以复制从当前光标到本行结尾的所有字符。
- 如果我们在某一行用ma做了标记（mark），那么就可以使用y'a命令来复制这一行了。

###### 粘贴

- 在完成复制之后，即可以使用p命令进行粘贴。p命令可以在一个文件中多次使用，每次都可以将刚删除或复制的内容重复粘贴在所希望的地方。当然这个命令也可以使用数字做前缀，明确的指出所要执行的次数。
- 小写的p命令是在当前行的下一行进行粘贴,，并将光标移到新插入行的开头处。
- 大写的P命令则是在当前的上一行进行插入，并将光标移到新插入行的开头处。
- gp命令是在当前行的下一行进行粘贴，并将光标移动到新插入行的下一行的开头处。
- gP命令是在当前的上一行进行粘贴，插入后光标移动新插入行的下一行的开头处。

##### 查找文本

###### 查找字符

- 命令f用于在本行内向前搜索。例如fx是向前（Forward）搜索字母x。而命令F是向后（Backward）搜索。例如Fx是向后搜索字母x。与f和F这两个相类似的是t和T命令。t命令类似于f向前搜索命令，所不同的是t搜索到时并不是将光标停在目标字符上，而是停在目标字符的前一个字符上。而T命令类似于F向后搜索命令，所不同的是T搜索到时并不是将光标停在目标字符上，而是停在目标字符的后一个字符上。
- 对于以上四个查找命令，我们可以重复执行这些操作。命令;是按照前一次的查找方向继续查找，如果要向相反的方向查找可以使用,命令。但是这些查找只是在行本行内进行，并不会将光标移动到其它的行。

###### 查找字符串

- 使用/string命令，可以向前（Forward）查找字符串string，按下回车后，光标就能跳转到匹配处。如果在整个文件中有多处匹配的内容，那么可以使用/命令，然后按下回车键继续刚才的查找。我们还可以使用n命令来继续刚才的查找命令。
- 我们也可以使用?string命令向后（Backward）查找。N也是逆向查找命令，他可以实现立即反向查找。
- 如果我们想要停止这一查找，可以使用ctrl+C命令
- Vim具有自动记录查找命令历史的功能，这样就不用重复输入查找命令了。例如你刚才做过的三次查找分别是：/one，/two，/three。而现在输入/，然后按上下方向键，就可以在屏幕底部看到刚才查找命令，这时只要按下回车就能够再次执行之前的查找命令了。

###### 指定光标放置位置

- 在默认情况下，Vim会将光标放在第一个匹配结果的开始处。例如你查找字符串set，光标将会停留在字母s之上。我们可以在命令中指定查找结束后光标停留的位置。
- 对于向前查找的命令，可以在斜线后用数字来指明光标所处的位置，例如/set/2或/set/+2命令都会在查找结束后将光标放在第一个set字符串之后第二行的开始处。命令中的数字可以是正数也可以是负数。如果仅是一个简单的数字，光标会被放在第一个匹配字符串之后或之前的数字所指定的行的开始处。正数表示是向后，而负数表示是向前。
- 参数b（begin）或s（start）会使得光标放在第一个匹配字符串的开头处。如果斜线后是b和数字，那么在查找结束后，光标将会放在第一个匹配字符串的开始处，然后向左或是右移动n个字符，这里的n即为数字所指定的数。如果为正数则是向右移动，如果是负数则是向左移动。例如/set/b2或/set/s+2命令，将使光标在查找结束后放在第一个匹配字符的开始处，然后向右移动两个字符，也就是说最后光标会位于第一个匹配字符串中的t的位置。将b改为s也是一样的效果。
- 而参数e会使得光标放在第一个匹配字符串的结尾处。同样我们也可以用数字来指定向右还是向左移动光标以及移动的字符数。例如/set/e命令会使光标放在第一个匹配字符处的结尾处。如果命令改为/set/e2，会将光标放在第一个匹配字符串的结尾处，然后向右移动2个字符。这里的数字如果是正数则向右移，如果为负数则向左移。
- 我们还可以在命令中指定偏移量。例如命令/set/e+2是在查找set字符串结束后，将光标放在第一个匹配字符串的结尾处，然后向右移动两个字符。/命令，将使用相同的偏移量重复前一次的查找。如果要重复前一次的查找，但是需要不同的偏移量，那么可以使用//5命令。如果不使用偏移量，则可以指明一个空的偏移量，如//命令。
- 查找命令?也可以实现类似的功能。例如?set?b5命令，是将光标放在最后一个匹配字符串的开头部分，然后向右移动5个字符。??-2命令，则继续前一次的查找命令，但是使用新的偏移量。??命令，是继续前一次的查找命令，但是不使用偏移量。

###### 立时查找字符串

- 如果我们想快速查找当前光标下的字符串，可以使用命令*，这个命令可以向前查找与当前光标下的字符精确匹配的字符串。而命令#，则向后查找与当前光标下的字符串精确匹配的结果。
- 如果当前光标下的字符串为word，在执行*命令查找时并不会与Word相匹配。如果使用相类似的`g*`命令，来查找word，则不会要求严格的精确匹配，那么就有可能和Word相匹配。而g#命令与其相同，只不过他是向相反的方向进行查找匹配。

###### 大小写敏感

- 在默认情况下，Vim是大小写敏感的。如果文件中包含有include,INCLUDE,Include等多个字符串。当我们使用命令/include来查找时，则只有include字符会被高亮显示。但是如果我们使用:set ignorecase命令，设置为忽略大小写，则include,INCLUDE,Include所有字符串都会被高亮显示。当然我们也可以使用:set noignorecase命令，重新设置为大小写敏感。
- 在设置了ignorecase选项后，我们查找字符串word，则会同时匹配word、Word，WORD等；如果我们查找字符串WORD，匹配的结果也是一样的。但是如果设置了:set ignorecase和:set smartcase两项之后，就会执行不同的匹配模式：如果输入的是小写字符，那么就会匹配各种可能的组合，与ignorecase选项的情况相同；但是如果在输入中有一个大写字符，那么这时就会转变为精确查找，与noignorecase选项的情况相同。
- 我们也可以在执行查找命令时，使用修饰符来控制大小写敏感。在命令中加入修饰符\C将执行大小写敏感的查找，比如?\Cword命令就只匹配单词word。而在命令中加入修饰符\c则执行忽略大小写的查找。

###### 设置查找选项

- 我们可以使用:set hlsearch命令设置高亮显示查找的文本，而:set nohlsearch命令则会关闭高亮显示。
- 如果想要立刻清除上次查找产生的高亮显示，可以使用:nohlsearch命令。
- 使用:set incsearch命令，将打开自动匹配选项。在进行查找时就会显示出不断匹配的过程。例如你想查找的内容是include，在打开这个选项后，当你输入/i，光标定位在i上，再继续输入n光标定位在in上，以此类推自动显示匹配的结果。我们也可以使用:set noincsearch命令，来关闭自动匹配选项。
- 在默认情下，输入查找的字符串之后，vim是从当前光标处向前查找，直到文件的结尾；如果没有找到，则会从文件的开头开始查找，直到光标所处的位置。通过:set nowrapscan命令，可以禁止这种循环查找的方式。如果已经查找到文件的结尾仍未发现匹配结果时，就会在底部显示出一条错误信息。如果想要重新启用循环查找方式，可以使用:set wrapscan命令进行设置。

##### 替换

- 利用:substitute命令，可以将指定的字符替换成其他字符。通常，我们会使用命令的缩写形式:s，格式如下：

  ```
  :[range] s/search/replace/[flags] [count]
  ```

  - *range*是指定范围，也就是在哪些行里做替换。而后是将字符串from替换成字符串to。

###### 替换标记

- 在默认情况下，替换命令仅将本行中第一个出现的的字符替换成给定字符。如果我们想要将所有出现的字符都替换成给定字符，可以在命令中使用*g*（global）标记：

  ```
  :%s/from/to/g
  ```

- 其他的标记（flags）包括：*p*（print），是要求打印所做的改动；*c*（confirm），是要求在做出改动以前先询问；*i*（ignorecase），是不区分大小写。我们可以组合使用标记，比如以下命令，将会显示将要做改动的文本并要求确认：

  ```
  :1,$ s/Professor/Teacher/gc
  
  replace with Teacher (y/n/a/q/l/^E/^Y)?
  
  这时你可以做出以下回答：
  
  y Yes：执行这个替换
  n No：取消这个替换
  a All：执行所有替换而不要再询问
  q Quit：退出而不做任何改动
  l Last：替换完当前匹配点后退出
  CTRL-E 向上翻滚一行
  CTRL-Y 向下翻滚一行
  ```

###### 指定范围

- 如果没有在命令中指定范围，那么将只会在当前行进行替换操作。以下命令将把当前行中的I替换为We。命令中的/i标记，用于指定区分大小写。

  ```
  :s/I/We/gi
  ```
- 以下命令将文中所有的字符串idiots替换成managers：

```
:1,$s/idiots/manages/g
```

- 通常我们会在命令中使用%指代整个文件做为替换范围：

```
:%s/search/replace/g
```

- 以下命令指定只在第5至第15行间进行替换:

```
:5,15s/dog/cat/g
```

- 以下命令指定只在当前行在内的以下4行内进行替换：

```
:s/helo/hello/g4
```

- 以下命令指定只在当前行至文件结尾间进行替换:

```
:.,$s/dog/cat/g
```

- 以下命令指定只在后续9行内进行替换:

  ```
  :.,.+8s/dog/cat/g
  ```

- 你还可以将特定字符做为替换范围。比如，将SQL语句从FROM至分号部分中的所有等号（=）替换为不等号（<>）：

  ```
  :/FROM/,/;/s/=/<>/g
  ```

- 在[可视化模式](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2010/11/vim-visual-mode.html)下，首先选择替换范围, 然后输入:进入命令模式，就可以利用s命令在选中的范围内进行文本替换。

###### 精确替换

- 在搜索*sig*时，也将匹配*sig*, *signature*, *signing*等多个单词。如果希望精确替换某个单词，可以使用“\<”来匹配单词的开头，并用“\>”来匹配单词的结尾：

  ```
  :s/\<term\>/replace/gc
  ```

###### 多项替换

- 如果想要将单词*Kang*和*Kodos*都替换为*alien*，那么可以使用|进行多项替换。

  ```
  :%s/Kang\|Kodos/alien/gc
  ```

###### 变量替换

- 使用以下命令可以将文字替换为变量的内容：

  ```
  :%s!\~!\= expand($HOME)!g
  ```

##### 撤销

###### 单线撤销

- 在Normal mode下使用u命令，或者在Command mode下使用:undo命令，可以撤销上一次的操作。

- 使用U命令，可以撤销所有针对当前行最近所做的修改。

- Vim可以进行多次撤销，这个次数是由选项undolevels来指定的。例如我们可以使用以下命令，设置撤消次数为5000：

  ```
  :set undolevels=5000
  ```

- 如果希望重做被撤销的操作，可以使用:redo或CTRL-R命令。

###### 分支撤销

- 以下述操作为例：新建文件并输入“大象”，然后在新的一行中输入“小牛”，返回Normal mode并按下u命令。这时输入“小牛”的操作被撤消，文件将只包含“大象”。接着输入“猩猩”，然后返回Normal mode并按下u命令，此时将撤消输入“猩猩”的操作，文件仍然只包含“大象”。所以你的“小牛”就再也找不回来了。而撤消分支（Undo branches）就可以解决这个问题。使用g-可以使文件重新包含入“大象”和“小牛”

  ![](https://pic2.zhimg.com/80/v2-c5e38593c67c4751cfa2892f50f94275_1440w.png)

- 如果你先撤销了若干改变，然后又进行了一些其它的改变。此时，被撤销的改变就成为一个分支。我们可以使用:undolist命令查看修改的各个分支。

  ![](https://pic1.zhimg.com/80/v2-692ec9c6942ac0c886ecafd5c4149b68_1440w.png)
  - "编号" 列是改变号。这个编号持续增加，用于标识特定可撤销的改变。
  - "改变" 列是根结点到此叶结点所需的改变数目。
  - "时间" 列是此改变发生的时间。

- 使用:undo命令并指定编号做为参数，则能够撤销到某个分支。

- 通过在不同的撤消分支间跳转，使用g-命令能够回到较早的文本状态；而g+命令则返回较新的文本状态。

- 我们还可以根据时间撤消操作：使用:earlier 10m命令退回到10分钟前的文本状态。也可以用:later 5s命令跳转到5秒以后的编辑状态。命令参数中的"s"代表秒，"m"代表分钟，"h"代表小时。

- 使用:help undo-tree和:help usr_32.txt命令，可以查看撤消操作的帮助信息。

##### 帮助信息

- 在帮助信息中的命令、选项或章节等链接上双击鼠标或点击ctrl-]键，就可以跳转到相关的帮助信息。点击ctrl-o或ctrl-t则可以在查阅过的帮助信息之间进行跳转。

- 使用以下命令，可以显示用户手册的目录：

  ```
  help usr_toc
  ```

- 通过set wildmenu设置命令，可以在窗口底部显示菜单选项。当我们并不知道确切的命令名称时，可以只输入开头的几个字母，然后按下Tab键，就将在wildmenu中显示可能匹配的命令。继续按Tab键，可以在这些命令列表间移动

- 使用:help ctrl<Tab>命令，可以列出所有和CTRL键相关的帮助主题。使用:help i_CTRL-R命令，则只显示在插入模式下CTRL-R的帮助信息；而:help c_CTRL-R命令，则显示在常规模式下CTRL-R的帮助信息。

###### 模糊查询

- 如果不知道具体的命令名称，那么可以使用以下命令在所有帮助文件中查询相关信息。例如，使用此命令，将逐一显示所有与插入模式相关的帮助信息。

  ```
  :helpgrep insert mode
  ```

- 可以使用:cnext命令，查看下一条帮助信息；使用:cprev命令，查看上一条帮助信息。

- 如果有很多相关的帮助信息，可以使用:clist命令，列示所有包含指定主题的帮助信息。

- 使用:cwin命令，则可以在QuickFix窗口中列示所有相关帮助信息的条目。利用鼠标滚轴、方向键或j,k移动命令可以在条目间移动，按下回车键则可以打开当前条目的帮助信息。使用:cclose命令，可以关闭QuickFix窗口。

###### 更多帮助资源

- :help quickref命令，可以查看快速索引：
- :help tips命令，可以查看使用技巧

### 高阶操作

##### 在词间移动

- Vim有单词（word）和字串（WORD）两种概念。word是指由iskeyword选项定义的字符串；而WORD则是指用空白符分隔的字符串。可以使用:help word和:help WORD命令，查看更多帮助信息。

###### 在word间移动

- [count]b 向后移动count个words

  [count]e 向前移动count个words,并且将光标置于word的末尾.

  [count]ge 向后移动count个words,并且将光标置于WORD的末尾.

  [count]w 向前移动count个words.

- 按照通常的定义，单词是一系列字母的组合。然而在C程序中，则认为字母、数字和下划线来组成一个单词，比如size56就会被认为是一个单词。但是在LISP程序中，可以在变量名中使用-，这时会认为total-size是一个单词，而在C程序中这却会被认为是两个单词。那么如何来解决这些定义的差异呢？Vim的解决方案是，使用以下选项来定义哪些是一个单词的，而哪些又不是。

  ```
  查看当前选项，可以使用下面的命令：
  :set iskeyword?
  命令会返回一组用逗号分隔的值
  iskeyword=@,48-57,_,192_255  这个其实是192-255
  
  如果我们想要单词中的字母是专一的元音，可以使用以下命令：
  :set iskeyword=a,e,i,o,u
  
  我们还可以使用横线来指定字母的范围。如果要指定所有的小写字母，可以用下面的命令
  :set iskeyword=a-z
  
  对于那些不能直接指定的字符，可以使用十进制的数字来表示。如果我们要指定小写字母和下划线为一个单词，可以使用下面的命令：
  :set iskeyword=a-z,45
  
  排除某一个字符，可以在这个字符前加上一个前缀^。例如我们可以定义一个单词由除了q以外的小写字符组成：
  :set iskeyword=@,^q
  
  iskeyword（命令iskeyword可以简记为isk）选项使用以下特殊字符：
  a 字符
  aa-z 所有由a到z的字符
  @ 由函数isalpha()所定义的所有字符
  @-@ 字符@
  ^x 除了x以外的字符
  ^a-c 除了a到c以外的字符
  ```

- 可以使用:help iskeyword命令，查看更多帮助信息。

###### 在WORD间移动

- [count]B 向后移动count个WORDS

  [count]E 向前移动count个WORDS,并且将光标置于WORD的末尾.

  [count]gE 向后移动count个WORDS,并且将光标置于WORD的末尾.

  [count]W 向前移动count个WORDS.

- 可以使用:help word-motions命令，查看在词间移动的更多帮助信息。

##### 文本对象

- 在Vim中，相比针对单个字符进行操作，对于单词、句子和段落等更大范围的文本对象（**text-objects** ）执行命令则更有效率。Vim的命令结构示例如下：

  ```
  [number]<command>[text object or motion]
  ```

  - 其中：number是指命令作用在几个文本对象之上。比如3个单词；command是指执行的具体命令。比如删除或复制；text object or motion是指具体的文本对象。比如单词、句子或段落。

- 文本对象命令只能在可视模式或操作符后使用。这些命令或以 "a" 打头，代表选择一个 ("a"n) 包含空白的对象；或以 "i" 带头，代表选择内含 ("i"nner) 对象: 它们不包含空白。另外，空白本身也是内含对象。这样，"内含" 对象总比 "一个" 对象选择较少的文本。
- 文本对象就是符合某一标准的在某两个界定符内的一串文本，比如一个单词，一个句子，一个字符串等。文本对象有二个优点，一是无论光标处于该文本对象的哪个字符中，你可以对整个文本对象进行操作；二是有些情况下你想要进行的操作正好就是一个文本对象的全部内容。
- 操作＋对象范围＋文本对象界定符
  - 单词和句子的界定符用 `w` 和 `s` 来表示，其它的用两个界定符中的任何一个都可以表示。如 `daw` 表示删除一个单词，`yis` 表示复制一个句子。`yi(`表示复制一个括号中的内容。
  - 操作有三种：v、y、d，分别为，选中、复制、删除；c命令是一个动作后面要跟具体的文本对象例如ciw
  - 文本对象共有两个范围，一是a，其实它就是英语单词a，表示一个文件对象，对该文本对象的操作会包括文件对象的界定符，如双引号字符串的双引号，括号，尖括号等。第二个是i，是英语单词inner的缩写，所以这表示操作范围在一个对象之内，不包括界定符。
- 文本对象类型
  - iw …inner word
  - aw …a word
  - iW …inner WORD
  - aW …a WORD
  - is …inner sentence
  - as …a sentence
  - ip …inner paragraph
  - ap …a paragraph
  - it …inner tag
  - at …a tag
  - i( or i) …inner block
  - a( or a) …a block
  - i< or i> …inner block
  - a< or a> …a block
  - i{ or i} …inner block
  - a{ or a} …a block
  - i[ or i] …inner block
  - a[ or a] …a block
  - i" …inner block
  - a" …a block
  - i` …inner block
  - a` …a block
- 应用实例
  - 使用ci)命令，可以删除括号内的所有内容，但保留括号本身。而ca)命令，则可以删除括号内的所有内容，以及括号本身。
  - 在某个开括号上，点击%键，光标将可以自动移动到相对应的闭括号上。通过与编辑命令组合，c%可以实现与ca)相同的功能。使用%命令，必须将光标放在括号之上；而使用a)命令，则光标可以在括号之上或括号内的任何位置。而且%命令，也是无法实现用i)命令效果的。
  - 使用cit命令，你甚至不用将光标移动到Tag之内，就可以快速修改其中的内容。这个是相对于XML格式上来说的。

##### 文本对象间移动

- 使用以下命令，可以按照[文本对象](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-10-TextObjects.html)（Text Objects）为单位来快速移动；同时，对于浏览C、Java代码和HTML、Markdown等标签语言文档，也更加友好和高效。当然，以下命令也接受[count]参数，以跳转多个对象。

  ![](https://pic1.zhimg.com/80/v2-f068c5ddf914159f5649f37c90ea8bdc_720w.jpg)

- 句子（sentence），是以 '.'、'!' 或者 '?' 结尾并紧随着一个换行符、空格或者制表符。结束标点和空白字符之间可以出现任何数量的闭括号和引号: ')'、']'、'"' 和 '''。段落和小节的边界也视为句子的边界。

- 段落（paragraph），是以每个空行或段落宏命令开始，段落宏由 'paragraphs' 选项里成对出现的字符所定义。它的缺省值为 "IPLPPPQPP TPHPLIPpLpItpplpipbp"，也就是宏 ".IP"、".LP"等 (这些是 nroff 宏，所以句号一定要出现在第一列)。小节边界也被视为段落边界。注意，空白行不是段落边界。

- 小节（section），是以每个首列出现的换页符（<C-L>，<FF>）或小节宏命令开始。小节宏由 'sections' 选项里成对出现的字符所定义。它的缺省值是 "SHNHH HUnhsh"，也就是宏 ".SH"、".NH"、".H"、".HU"、".nh" 和 ".sh"。

- 按其他对象移动

  <img src="https://pic4.zhimg.com/80/v2-e8d6119a6e4c954c01848c8f181b3557_720w.jpg" style="zoom:50%;" />

  - 绿色，标志光标初始位置；

  - 红色，标志光标移动到的目的位置；

  - 橙色，标志光标移动的轨迹；

    <img src="https://pic2.zhimg.com/80/v2-33ab7e788ec62c83bc035b7cffa52c95_720w.jpg" style="zoom:50%;" />

- [上面图片来源](https://of-vim-and-vigor.blogspot.com/2012/11/vim-motions.html)

##### 匹配成对字符

###### matchpairs

- matchpairs选项，用来控制哪些字符可以通过`%`命令进行匹配。此选项的默认值如下：

  ```
  :set matchpairs=(:),{:},[:]
  ```

  - 也就是说，在开括号“(,{,[”上点击`%`键，将会自动跳转到对应的闭括号“),},]”上；同理，在闭括号上点击`%`键，也会跳转回到对应的开括号上；同时，匹配跳转也能够正确处理括号嵌套的情况。
  - 如果当前光标下并非括号，那么点击`%`键，将自动在本行内向前查找并定位到括号之上。

- 如果需要新增匹配类型，例如增加对于HTML文件中的尖括号的匹配，那么可以使用以下命令：

  ```
  :set mps+=<:>
  ```

- 利用[自动命令](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-49-01-autocmd.html)（autocmd），可以针对特定文件类型设置匹配字符。例如针对C和Java代码，增加对于“=”和“;”的匹配：

  ```
  :au FileType c,cpp,java set mps+==:;
  ```

###### showmatch

- 如果希望在输入闭括号时，短暂地跳转到与之匹配的开括号，那么可以设置以下选项：

  ```
  :set showmatch
  ```

###### matchtime

- 'matchtime'选项，用于控制显示配对括号的时间，其单位为0.1秒，默认值为5，即0.5秒。

  ```
  如果希望持续显示配对括号1.5秒，那么可以使用以下命令：
  :set matchtime=15
  ```

###### matchit插件

- [matchit](https://link.zhihu.com/?target=https%3A//github.com/chrisbra/matchit)插件扩展了`%`命令的功能，支持if/else/endif语法结构；支持HTML标签。使用`:help matchit-languages`命令，可以查看当前支持的所有语言列表。

- 从Vim 6.0开始，[matchit](https://link.zhihu.com/?target=https%3A//github.com/chrisbra/matchit)插件伴随vim发行，内置于`$VIMRUNTIME\pack\dist\opt\matchit`目录中，并不需要单独安装。

- 在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件中增加以下命令，可以启用matchit插件：

  ```
  packadd! matchit
  ```

##### ctrl+F设置

- 在Linux下的Vim中，Ctrl-F键默认设置为，向前（Forward）滚动屏幕；而在Windows和Mac下的Vim中，Ctrl-F键默认设置为，打开查找对话框。

- 此设置是在2017年2月9日发布的8.0.0321版本中开始生效的。通过查看 "C:\Program Files (x86)\Vim\vim81\mswin.vim" 文件，可以发现 Ctrl-F 被设置为打开查找对话框。

- 为了保持不同操作系统之间的操作一致性，建议在[配置文件(vimrc)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)中增加以下代码，以重新将Ctrl-F键设置为向前滚动屏幕：

  ```
  unmap <C-F>
  ```

  - 注意，以上设置命令必须放置在以下载入代码之后，以确保设置不会被覆盖：

    ```
    source $VIMRUNTIME/mswin.vim 
    ```

##### 滚动屏幕

- 命令CTRL-U可以向上翻滚半屏，但是可以通过设置scroll选项来控制这个命令翻滚的行数。例如命令:set scroll=10可以使得Vim一次翻滚10行。也可以通过改变CTRL-U命令的参数来改变翻滚的行数。例如命令2CTRL-U可以使得Vim一次向上翻滚两行。

- 当光标到达窗口上端或下端时，窗口要发生滚动。我们可以通过设置scrolljump选项来控制这个翻滚行数的大小，默认情况下为1。例如命令:set scrolljump=5将翻滚量设为5。与其相类似的就是sidescroll选项，所不同是后者控制水平的翻滚。

- 通常情况下，窗口翻滚是在光标到达窗口顶部或底部时才发生的。我们可以通过scrolloff选项来控制光标与顶部或是底部有多少距离时发生。例如命令:set scrolloff=3将值设为3，当光标与顶部距离为三行时发生翻滚，且翻滚后光标与底部相距三行。

- ```
  （N）Ctrl-E：窗口向下滚动N行，默认向下滚动一行。（光标没有移动）
  （N）Ctrl-Y：窗口向上滚动N行，默认向上滚动一行。（光标没有移动）
  （N）Ctrl-D：窗口向下滚动N行，默认滚动窗口行数的一半。（光标没有移动）
  （N）Ctrl-U：窗口向上滚动N行，默认滚动窗口行数的一半。（光标没有移动）
  （N）Ctrl-F： 窗口向下滚动N页。（光标被迫移动）
  （N）Ctrl-B： 窗口向上滚动N页。（光标被迫移动）
  ```

  

###### 放置行

- 有时我们希望将指定的行放在屏幕顶端。先将光标放在指定的行上，然后输入z<Enter>，这一行就会出现在屏幕的顶端了。我们还可以利用参数将指定的行置于屏幕顶端。例如命令8z<Enter>就是将第八行置于屏幕顶端。这个命令将指定的行置于顶端，并将光标移动到本行第一个非空白字符处。如果要将指定行置于顶端，并将光标保持在一行的当前位置不变，可以使用zt命令。

- 如果要将指定的行放在屏幕底部，可以使用命令z-或是zb。所不同的是，前者将光标放在这一行中第一个没有空白符的字符处，而后者是保持光标的位置不变。

- 命令zz或是z.可以将指定的行放在屏幕的中部。这两个命令的不同就是，前者保持光标的位置不变，而后者是将光标置于第一个非空白的字符处。

- H将光标移动到屏幕顶端， M移动到屏幕中间，L移动到屏幕底部

  ![](https://pic4.zhimg.com/80/v2-8071b9a8aa606a05441a6166e422c5bb_720w.png)

##### 寄存器

- 将寄存器与各种删除、复制、粘贴命令组合使用，能够大大提高编辑文本的效率。

###### 指定寄存器

- 在复制或删除文本时，可以使用"register命令将文本放入指定的寄存器中。例如以下命令，将复制的文本放到寄存器*a*中，同时文本也会被放入未命名寄存器中。

  ```
  "ayy
  ```

- 如果再使用相应的大写字母来指定寄存器，那么会将当前行内容追加到寄存器*a*中，这时该寄存器中就有了两行文本。

  ```
  "Ayy
  ```

###### 查看寄存器

- 使用registers name命令，可以查看特定寄存器中的内容：

  ```
  registers a
  ```

- 如果想要查看所有寄存中的内容，可以使用以下命令：

  ```
  :registers
  ```

###### 寄存器类别

<img src="https://pic3.zhimg.com/80/v2-9752311b4c4e51ddb02f59ce25e4830e_720w.jpg" style="zoom:80%;" />

- **未命名寄存器（The Unnamed Register）** 当使用y命令复制文本，或使用d、c、s、x等命令删除文本时，文本将自动被放入**""**未命名寄存器。即使你在复制或删除文本时，已经指定了寄存器（例如使用"xdd命令），这些文本也将同时被放入"x和""寄存器。
- **数字寄存器（The Numbered Registers）** **"0**包含最近复制的文本；**"1**包含了最近删除或者修改的文本。区别在于："0不断被复制的文本所覆盖；而在删除文本时，如果指定了寄存器或者文本小于一行，那么"1将不会被覆盖。数字寄存器1-9可以看作是删除历史， 你可以从中找到早先删除的文本。比如使用了三次`dd`命令，那么这三行文本被分别存放在寄存器1,2,3中，可以通过命令`"1P`,`"2P`,`"3P`将这些文本再粘贴回来。
- **行内删除寄存器（The Small Delete Register）** 当删除文本少于一行时，内容将被放入**"-**寄存器，除非指定了其它寄存器。
- **命名寄存器（The Named Registers）** 当文本被放入以小写字母命名的寄存器（例如**"a**）时，该寄存器原有的内容将被覆盖；而使用以大写字母命名的寄存器（例如**"A**）时，将会把文本追加到原有内容之后。
- **只读寄存器（The Read-Only Registers）** 你只能从只读寄存器中粘贴内容，而不能放入文本。**"%**包含当前文件名；**".**包含最近插入的文本；**":**包含最近执行的命令行。
- **轮换文件寄存器（The Read-Only Registers）** **"#**包含当前窗口轮换文件的名字。它影响CTRL-^的工作方式。
- **表达式寄存器（The Expression Register）** 可以进行表达式计算并返回结果。在常规模式下，输入**"=**，就会在Vim底部显示以“=”开始的提示行，可以在其中输入表达式并按回车键确认。随后使用命令`p`，可以将表达式的结果粘贴到文本中。例如在`=`提示符后输入“5*5”并按回车，然后输入命令p，就可以将计算结果“25”插入文本中了。在插入模式下，点击Ctrl-R=快捷键，也可以进入`=`提示行，输入表达式然后点击回车键，将计算结果插入到当前光标处。也就是说，不用离开插入模式，也无需额外执行粘贴命令，即可以完成表达式计算。在表达式寄存器中，不仅可以使用通常的算术运算符，还可以使用Vim特定的函数和运算符。例如通过表达式寄存器来得到环境变量的值（例如"=$HOME）。如果没有输入任何表达式而直接按回车键，那么Vim将执行最近使用过的表达式。
- **选择和拖拽寄存器（The Selection and Drop Registers）** 有3个寄存器用于保存选中的文本：在Mac和Windows下，**"\***和**"+**，都用于访问系统剪切板；在Linux下，**"+**用于访问系统剪切板，而**"\***包含选中的文本。使用`"+y`命令，可以将当前选中的文文本复制到系统剪切板中。而`"+p`命令，则可以粘贴系统剪切板中的内容。通过剪切板寄存器，能够在不同的Vim编辑器或者是其他应用程序之间，进行文本交换。**"~**包含上次从其它应用程序拖拽到Gvim中的文本。
- **搜索模式寄存器（Search Pattern Register）** 当通过`/`命令进行搜索时，所使用的模式将被自动放入**"/**寄存器。

###### 粘贴寄存器

- 命令:put会将寄存中的内容粘贴到指定的文本行后面。使用以下命令，可以将寄存器中的内容粘贴到第五行的后面:

  ```
  :5put a
  ```

- 如果要将文本放在这一行的前面，可以用以下命令：

  ```
  :5put! a
  ```

- 你也可以使用p命令，将x寄存中的文本粘贴到光标之后：

  ```
  "xp
  ```

- 而P命令，则将x寄存中的文本粘贴到光标之前：

  ```
  "xP
  ```

- 如果直接使用p或P命令，而没有指明特定寄存器，那么将粘贴未命名寄存器中的内容。

- 使用以下命令，可以粘贴上次插入的文本，方便你录入重复的内容：

  ```
  ".P
  ```

- 如果要粘贴系统剪切板中的内容，在Insert mode下可以利用快捷键Shift+Ins，而在Normal mode下，可以使用以下命令：

  ```
  "*p
  ```

- 在插入模式下，点击CTRL-R然后输入寄存器的标识符，可以粘贴相应寄存器中的内容到当前位置。例如：

  ```
  CTRL-R: 将粘贴最近执行的命令；
  
  CTRL-R/ 将粘贴最近使用的搜索模式；
  
  CTRL-R0 将粘贴"0寄存器的内容；
  
  CTRL-Ra 将粘贴"a寄存器的内容。
  ```

- 使用以下命令，可以查看相关帮助信息：

  ```
  :help i_CTRL-R 
  ```

##### 重复命令

- .（Dot）命令，可以重复上次的修改。而上次的修改，可以是针对单个字符、整行，甚至是整个文件。所以Dot命令，是一个作用范围极广的强大命令。

###### 重复单个命令

- .命令重复执行了x命令，用于删除当前光标下的字符

  ![](https://pic1.zhimg.com/80/v2-ae1ed3b31455ad6823c8b3f896902948_720w.png)

- .命令重复作用于整行之上的删除操作

  ![](https://pic2.zhimg.com/80/v2-26a6dc54a85e277a94e1678593e0abb5_720w.png)

###### 重复多个命令组合

- 假设我们有以下代码：

  ```
  var foo = 1
  var bar = 'a'
  var foobar = foo + bar
  ```

  - 如下图所示：首先，我们使用A命令进入插入模式并在当前行的末尾增加分号；然后，退回到常规模式；之后，移动到一下行并利用.命令重复插入分号的操作。

    ![](https://pic4.zhimg.com/80/v2-744e645261febcfc56bfaf14b97adc77_720w.png)

###### 重复命令与其他命令的组合

- 假设我们有以下代码：

  ```
  var foo = "method("+argument1+","+argument2+")";
  ```

  - 在以下实例中：我们希望在每个加号前后分别插入空格，以提高代码的可读性。首先，我们使用f命令查找加号；然后，使用s命令将加号替换为“ + ”；随后，退回到常规模式；之后，就可以利用;.命令查找下一个加号并重复执行替换操作。

    ![](https://pic3.zhimg.com/80/v2-b24817322b00d67481fba70739bf652a_720w.png)

- 还得使用；来查找下一个加号然后使用.命令

##### 持久性撤销

- 持久性撒消（persistent undo），会将撒消树保存到撤销文件中，因而即使被编辑文件被关闭再打开多次，也可以撤销过去进行的所有修改（当然不能超过[undolevel](https://link.zhihu.com/?target=http%3A//vimdoc.sourceforge.net/htmldoc/options.html%23'undolevels')的限制）。

###### 启用持久性撤销

- 默认情况下，Vim并没有启用持久性撤销。使用以下命令，可以启用持久性撤销：

  ```
  set undofile 
  ```

  - Vim将为正在编辑的文件，分别创建独立的撤销文件，用以保存支持撤销操作的信息。

###### 生成撤销文件

- 撤销文件通常保存在文件本身所在的目录里。使用以下命令，可以将撤销文件集中保存到指定的目录：

  ```
  set undodir=$HOME/.vim/undodir
  ```

  - 请注意，需要确保您指定的目录已经存在。
  - 生成的撤销文件，将以所编辑文件的完整名称命名。其中包括了完整的路径名，其中“/”将以“%”代替：

- Vim只会创建撒消文件，而永远不会去删除它们；如果你更改了文件名称，那么旧文件名所对应的撤销文件也不会被自动删除。建议，将撤销文件存储到指定目录（比如temp临时目录），并定期进行手动清理。

###### 撤销操作

- 使用:earlier {N}f 和 :later {N}f 命令，可以根据写入次数进行撤销。

  ```
  例如以下用命令，可以恢复到上次写入时的文本状态
  :earlier 1f
  ```

- 使用`:help persistent-undo`命令，可以查看关于持久性撤消的[帮助信息](https://link.zhihu.com/?target=http%3A//vimcdoc.sourceforge.net/doc/undo.html%23undo-persistence)。

##### 运行外部命令

- 使用`:!`命令，可以运行一个外部系统命令。例如，以下命令将打开终端窗口，并在其中显示当前日期：

  ```
  :!date
  ```

- 使用`:!!`命令，可以重新执行最近一次运行过的命令。

- 使用`!!`命令，可以运行外部命令并将输出结果做为当前行的内容。例如，输入`!!date`命令，将会把date命令的输出结果插入到文件中，当前行中的原有内容将会被覆盖。

###### 读取命令输出

- 在常规模式下，使用`:read`命令，可以读取命令执行的输出结果。例如以下命令，将在当前行之下新增一行并插入当前日期。

  ```
  :read!date (For Linux)
  
  :read!date /t (For Windows)
  ```

###### 调用命令终端

- 使用`:shell`命令，不需要退出Vim，就可以打开操作系统的命令终端窗口，并在其中执行一个或多个Shell命令。在终端中使用`exit`命令，则可以退回到Vim。
- 使用Vim8引入的`:terminal`命令，将在新建的水平分割窗口中进入命令终端。也可以使用`:vertical :term`命令，在新建的垂直分割窗口中进入命令终端。
- 如果无法正常调用:terminal命令，那么请使用`:version`命令，查看是否包含**+terminal**关键字，以确认在当前版本Vim中已启用此特性。
- 在命令终端中，点击**`Ctrl-\-N`**快捷键，将从Terminal-Job模式切换至Terminal-Normal模式。在Terminal-Normal模式下，可以像在Vim常规模式下一样，使用光标键或命令来移动光标，也可以使用鼠标或命令来选择和复制文本，以便于将命令输出复制到其他文件。点击**i**键，则可以返回Terminal-Job模式，继续执行命令。上面这个快捷键是按着ctrl在按\然后按N键

###### QuickFix

- 某些Vim命令，将会使用QuickFix列表在不同文件的不同位置间导航。例如：使用:make命令进行编译时，遍历编译错误；使用:vimgrep命令进行搜索时，遍历匹配结果；使用:helpgrep命令查找[帮助信息](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-08-help.html)时，遍历匹配的主题。

- 执行以下命令，将在当前文件夹中的所有HTML文件中，搜索字符串“options”：

  ```
  :vimgrep options *.html
  ```

  - 在屏幕底部，将显示查找到的第一个匹配结果：

- 输入`:copen`或`:cwindow`命令，将在水平分隔窗口中，打开QuickFix列表以显示所有匹配结果：你可以使用ctrl+Wj快捷键，移动到QuickFix窗口。关于在多个窗口之间的跳转操作，请参阅[窗口(Window)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-14-MultiWindows.html)章节。

- 使用以下快捷键，可以在QuickFix列表中进行移动或搜索；当到达想要查看的列表项时，点击Enter键，将会打开匹配文件并精确定位到查找结果所处的位置。

- k向上移动↑j向下移动↓Ctrl+b向上翻页pageUpCtrl+f向下翻页PageDown/string向前（Forward）查找字符串string?string向后（Backward）查找字符串string

- 注意，如果您在Windows和Mac下，无法利用Ctrl+f键进行翻页，那么请重新恢复[Ctrl-F设置](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-11-01-Scroll-CtrlF.html)。

- 你也可以使用以下命令，直接跳转到匹配文件的查找结果所处位置：

  ```
  :cnext移动到下一个匹配处
  :cprevious移动到上一个匹配处
  :cfirst移动到第一个匹配处
  :clast移动到最后一个匹配处
  ```

- 使用以下命令，可以关闭QuickFix窗口：

  ```
  :cclose
  ```

- 使用`:help quickfix`命令，可以查看关于QuickFix的更多帮助信息。

### 模式详解

##### 插入模式

- ```
  i在光标之前，进入插入模式
  I在本行开头，进入插入模式
  a在光标之后，进入插入模式
  A在本行结尾，进入插入模式
  o在本行之后新增一行，并进入插入模式
  O在本行之前新增一行，并进入插入模式
  s删除当前字符，并进入插入模式
  S删除当前行中的所有文本，并进入插入模式
  
  c命令是一个动作后面要跟具体的文本对象例如ciw
  cc命令是删除本行并进入插入模式
  ```

- 通过在i，I，a，A命令中增加数字前缀，可以批量插入内容，以避免重复输入。例如：输入`50i*`命令，然后点击**Esc**键，将一次性插入50个星号；使用`25a*-`**Esc**命令，则将一次性插入25个星号和短线的组合。

- 通过在小写s命令中增加数字前缀，可以替换多个字符。例如：希望将“www.vim.org”更改为其它网址，可以首先将光标移动到字符“v”处，然后执行`3s`命令，删除3个字符并进入插入模式输入其它域名。

- 通过在大写S命令中增加数字前缀，可以替换多行内容。例如：执行`3S`命令，将删除2行文本，并将第3行文本清空，然后进入插入模式。

###### 在插入模式中编辑

- 在插入模式下，不能使用h，j，k，l键来移动光标，而必须使用光标移动键。使用以下命令，可以查看使用特殊快捷键进行移动和操作的说明：

  ```
  :help ins-special-keys
  ```

- 在插入模式下，可以使用各种快捷键来操作文本，而不需要首先退回到常规模式，然后再执行命令。例如：使用**ctrl-U**键，可以删除光标之前的所有文字；而**ctrl-W**键，则可以删除光标之前的一个字符；使用**ctrl-T**键，可以增加缩进；而**ctrl-D**键，则可以减少缩进。请使用以下命令，查看插入模式下快捷键的更多帮助信息：

  ```
  :help ins-special-keys
  ```

- 使用**CTRL-O**快捷键，可以进入命令模式执行Vim命令，然后重新回到插入模式，以避免多次切换模式的繁琐。例如，首先使用**CTRL-O**进入命令模式，然后执行`dw`命令来删除单词，在执行完毕之后将重新回到插入模式。

- 使用以下命令，可以查看关于插入模式的帮助信息：

  ```
  :help insert.txt
  ```

- 使用以下命令，可以查看关于快速插入文本的更多技巧。比如：补全、重复插入、从另一行拷贝、插入一个寄存器内容、[缩写](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-52-Abbreviation.html)和[插入特殊字符](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-65-Listchars.html)等等：

  ```
  :help usr_24.txt 
  ```

##### 替换模式

- 使用大写`R`命令，将进入替换模式（屏幕底部显示“--REPLACE--”）。此时新输入的文本将直接替代/覆盖已经存在的内容，直至点击ESC键返回常规模式。
- 使用小写`r`命令，将进入单字符替换模式，此时新输入的字符将替代光标之下的当前字符，然后自动返回到常规模式。
- 通过在r命令中增加数字前缀，可以一次性替换多个字符。例如，将光标定位到“||”字符处，然后执行`2r&`命令，可以将其替换为“&&”。
- 使用`gR`命令，将进入虚拟替换模式（virtual replace mode）（屏幕底部显示“--VREPLACE--”），其与替换模式最主要的区别在于，对<Tab>键和换行符的不同处理方式。
- 对于<Tab>键的处理方式
  - 在替换模式（REPLACE）下，在原有<Tab>键处输入字母'a'，将直接替代<Tab>键所占用的所有空格的位置，文本格式遭到破坏：
  - 在虚拟替换模式（VREPLACE）下，在原有<Tab>键处输入字母'a'，将仅仅替代单个空格，文本格式保持不变：
  - 从以上实例可以发现：替换模式（REPLACE）将<Tab>键作为一个整体来处理（不管其真实占用多少个空格位置）；而虚拟替换模式（VREPLACE）则将<Tab>键拆分为多个独立的空格来分别处理。如果文本以<Tab>分隔排布，在编辑过程中希望保持原有的文本缩进和排版格式，那么建议使用虚拟替换模式。
- 对于<NL>换行的处理方式
  - 在替换模式（REPLACE）下，输入<Enter>回车键将增加新行：
  - 在虚拟替换模式（VREPLACE）下，输入<Enter>回车键将用新行替代当前行内容（即清空当前行）：
- 使用`gr`命令，可以进入单字符虚拟替换模式。在替换光标下的当前字符之后，将自动返回到常规模式。
- 注意上面的gR和gr命令区别

##### 可视化模式

- 在可视化模式下，可以对一个文本块的整体进行操作。例如，首先高亮选中一部分文本，然后用d命令删除这个文本块。可视化模式的好处在于，不但可以大大提高操作的效率，而且还可以在做改动之前，就看到操作将影响的文本。
- 可视化模式可以分为以下三种：
  1. 用`v`命令进入的**字符可视化模式（Characterwise visual mode)**，文本选择是以字符为单位的。
  2. 用`V`命令进入的**行可视化模式（Linewise visual mode)**，文本选择是以行为单位的。
  3. 用`ctrl-V`进入的**块可视化模式（Blockwise visual mode）**，可以选择一个矩形内的文本。（注意：在Windows中，ctrl-V可能已经被影射为粘贴操作，可以使用`ctrl-Q`进入块可视化模式。）
- 命令`gv`可以重复前一次可视化模式时选中的文本。如果已经在可视化模式下，执行该命令会选中前一次选择的文本。如果重复行执行gv命令，就会在当前选中的文本和前一次选中的文本之间进行切换。
- 在可视模式下选中然后按:(冒号)就会看到命令行有字符'<,'>这个代表选中的区域，此时我们可以写一个normal命令就可以执行在normal模式下可以执行的命令和需要执行的东西，例如给选中的行加后缀，此时选中之后按冒号，`'<,'>normal A.png`，此时就会在每一行的尾部加上.png

###### 在可视化模式下移动

- 如果你已经在可视化模式下选择了若干文本，并且希望移动到已选择文本的另一结尾处，那么可以使用`o`命令。
- 如果你使用的是块可视化模式，那么已选择的区域将有四个角落。`o`命令只能移动到对面的一个角落，这时你可以使用`O`命令移动到同一行的另一个角落。
- 这样如果选择的块中行不是很整齐，我们就可以移动到其他的位置继续选择，这样在块模式下选择出来的就可以是不平整的

###### 在可视模式下编辑

- 在可视化模式下，我们可以进行各种编辑操作。如`d`命令可以删除高亮显示的文本，而`D`命令则会删除一行，即使这一行中只有部分文本是高亮显示的。类似的，`y`命令将复制高亮显示的文本，而`Y`命令会复制整行。

- 在块可视化模式下，使用`c`命令将删除高亮选中的文本并进入插入模式，在你输入文本并点击Esc返回之后，输入的文本将插入到块选中的每一行里。

- 而`C`命令会删除从选中文本到行尾的所有字符并进入插入状态。

- 针对高亮显示的文本块，我们可以用命令`~`进行大小写转换。用命令`>`增加缩进，或用命令`<`减少缩进。

- 我们还可以利用可视化模式，来合并多行文本。`J`命令可以将高亮显示的文本内容合并为一行，同时以空格来分隔各行。如果不希望在行间插入空格，那么可以使用`gJ`命令。

- 使用`g?`命令，可以使用rot 13算法来加密高亮显示的文本。针对同一个文本再次执行加密命令，就可以进行文本解密。

- 在可视化模式下，按下:键就可以对选定范围进行操作。例如：我们先在可视化模式下选中文本，然后执行`:write block.txt`命令，就可以将文本块写入另一文件中。选择多行，然后执行`:sort`命令，则可以对选中的文本进行排序。

- `Istring<Esc>`命令，可以快速地在块可视化模式下添加文本。比如先用`^`命令，移动到行首；然后使用`ctrl-Q`进入块可视化模式；再利用`j`命令选中多行；而后使用`I--`命令，就可以在每行开头增加注释符。如果选中文件按i(小写的)就会删除选中的

- 如果在块可视化模式下，仅仅选中了某些行，那么`Ivery<Esc>`命令将不会改变未选中的行。Ivery表示先按I然后输入very

  ![](https://pic3.zhimg.com/80/v2-7bd7d985e609855395fd5fe29dfec5da_720w.jpg)

- 在块可视化模式下，使用`r`命令，然后输入单个字符，将会把所有已选中的字符都替换为输入的字符。如果仅仅选中了某些行，那么未选中的行将不会受到影响。输入单个字符，例如按一个x，表示将所有选中的字符变为x
- 在块可视化模式下，使用`A`命令，然后输入字符，输入的字符将会被添加到块之后。即使仅仅选中了某些行，但是未选中的行也会受到影响。

##### 选择模式

- 选择模式，可以理解为另一种可视化模式。在选择模式下，可以对选中的文本进行快速操作。比如先高亮选中文本，然后用Backspace来删除这段文本；或者先高亮选中文本，然后用输入的内容来替换这些文本。执行操作之后，Vim将自动进入[插入模式(Insert Mode)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-42-InsertMode.html)。

- 选择模式与可视化模式的主要区别在于：在可视化模式下，可以选中文本，然后执行命令操作。也就是说，要用命令来结束可视化模式。而在选择模式下，命令仅限于Backspace（用于删除操作）和可打印的字符（用于替换操作）。因为不需要输入命令，所以操作变得更为简单，但同时也存在很多限制。

- 选择模式。用鼠标拖选区域的时候，就进入了选择模式。和可视模式不同的是，在这个模式下，选择完了高亮区域后，敲任何按键就直接输入并替换选择的文本了。和windows下的编辑器选定编辑的效果一致。普通模式下，可以按gh进入。选择模式就是类似于notpad++这种编辑器，选中之后可以删除，可以直接输入字符相当于删除选择的字符，没有其余的操作

- 常规模式下输入gh进去到选择模式，gH进入行选择模式，gCTRL+H进入块选择模式

- 在[可视化模式(Visual Mode)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-45-VisualMode.html)下，可以使用Ctrl + g快捷键，进入选择模式。Vim将根据当前所处的可视化模式的类型，自动进入与之一致的字符/行/块选择模式。再次点击ctrl-G键，将返回到可视化模式。

- 可以使用ctrl-O命令从选择模式切换到可视化模式。

- 在选择模式下移动光标比在正常模式下要困难一些。因为输入任何可打印字符和回车符，Vim就会删掉已选中的文本并进插入状态。所以要选择文本就只能使用方向键、CTRL以及功能键。

  - 如果希望使用Shift键来扩展选择，那么需要在'keymodel'选项中包含"startsel"：

  ```vim
  :set keymodel=startsel,stopsel
  ```

  - 如果要在选择模式下用鼠标来选择文本，需要设置以下选项：

  ```vim
  :set selectmode=mouse
  ```

- 使用Esc或Ctrl-[键，可以退出选择模式。

- 帮助信息

  ```vim
  :help select-mode
  ```

##### 命令行模式

- 输入`:`命令，使用`/`或`?`搜索命令，都将进入命令行模式。用户可以在屏幕底部的命令行中输入命令，或者使用以下快捷键遍历之前的命令历史，然后点击<Enter>键来执行命令。

  <img src="https://pic1.zhimg.com/80/v2-eb1966f79ad64badb9b792e68b1519b4_720w.jpg" style="zoom:67%;" />

- 输入部分命令，比如输入`:set`，然再点击上下光标键，将自动对命令历史纪录进行过滤，仅显示以“set”开头的命令历史纪录。在输入`/`和`?`查找命令时，此特性同样有效。请注意，此时是大小写敏感的。

- 继续键入命令`:set i`之后，按下Tab或Ctrl+D键，将显示以“i”开头的set命令；继续按Tab键，则可以在这些命令列表间移动，按下回车键就可以执行该命令。这样我们可以看到set设置的命令，不需要那么死记硬背了

- 进入命令行模式之后，点击Ctrl+rCtrl+w键可以将当前光标下的[word](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-09-word.html)粘贴到命令行中；点击Ctrl+rCtrl+a键可以将当前光标下的[WORD](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-09-word.html)粘贴到命令行；点击Ctrl+r%键可以将当前文件名粘贴到命令行。

- 利用以上快捷键，可以大大简化命令行的输入。比如想要替换光标下的单词，那么只要输入:substitute命令，然后再点击Ctrl+r和Ctrl+w键，就可以将光标下的单词插入到命令行中，而不需要手工输入替换的文字了。

  ```
  :%s/<Ctrl+r><Ctrl+w>//g
  ```

- 比如在编辑[vimrc配置文件](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)时，会面对大量的设置命令，只需要将光标移动到配置选项之上，输入:help命令，然后点击Ctrl+r和Ctrl+w键，就可以查询该关键字的帮助信息：

  ```
  :help <Ctrl+r><Ctrl+w>
  ```

- 使用`:help c_CTRL-R_CTRL-W`命令，可以查看关于Ctrl+r和Ctrl+w键的帮助信息。使用`:help cmdline-editing`命令，可以查看关于命令行编辑的帮助信息。使用`:help :`命令，可以查看关于命令行模式的帮助信息。

###### 命令行窗口

- 可以使用以下四种方式，来打开命令行窗口：

  - 在命令行模式下，使用CTRL-F快捷键打开命令行窗口，并显示命令历史纪录；
    请注意，您可以使用`:set cedit`命令，更改此快捷键。
  - 在常规模式下，使用`q:`命令打开命令行窗口，并显示命令历史纪录；
  - 在常规模式下，使用`q/`命令打开命令行窗口，并显示向前查找（search forward）的历史纪录；
  - 在常规模式下，使用`q?`命令打开命令行窗口，并显示向后查找（search backward）的历史纪录；

- 我们可以将命令行窗口，视为常规的[缓冲区 (Buffer)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)来操作。使用k和j键，可以在命令历史纪录中上下移动；也可以使用`/`命令查找命令历史纪录，并在此基础上进行修改，然后点击<Enter>键来执行命令（命令行窗口也将同时关闭）。

- 如果同时打开多个[缓冲区 (Buffer)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)，那么可以在一个缓冲区的命令行窗口使用`yy`命令复制一条命令，然后在另一个缓冲区的命令行窗口中粘贴并执行该命令，或者在命令行中使用`:@"<CR>`来执行复制的命令。也就是说，你可以很方便地在多个缓冲区中，重复执行命令（比如相同的:%s/old/new/g替换操作），而不必多次手工输入命令。

- 使用以下命令，可以设置命令行窗口的高度（默认值为7）：

  ```
  :set cmdwinheight=n
  ```

- 使用`:help command-line-window`命令，可以查看命令行窗口的更多帮助信息。

### 文字处理

##### 换行

- 在早期的打印机时代，开始新的一行要占用两个字符的时间。如果到了一行的结尾处，你要快速回到新的一行的开头，需要打印针头在纸面上飞快地掠过，常常会在纸面上留下污点。解决这个问题的办法就是，用两个字符：一个字符<Return>来移到第一列，另一个字符<Line feed>来新增一行。

- 计算机产生以后，存储较为昂贵，在如何解决回车换行这个老问题上，人们产生了不同的意见。UNIX人认为在到达一行的结尾时新增一行<Line feed> (LF)，而Mac人则认同<Return> (CR)的解决办法，MS则坚持古老的<Return><Line feed> (CRLF)的方法。这就意味着，如果你将一个文件从一个系统转移到另一个系统，就面临着回车换行的问题。而Vim编辑器则会自动识别出出这种文件格式方面的区别，并做出相应处理。

- fileformats选项，用于处理文件格式。以下命令告诉vim将UNIX文件格式做为第一选择，而将MS-DOS的文件格式做为第二选择：

  ```
  :set fileformats=unix,dos
  ```

- 检测到的文件格式会被存放在fileformat选项中，我们可以用以下命令来查询：

  ```
  :set fileformat?
  ```

- 在默认情况下，Vim认为文件是由行组成的，并且文件最后一行是以<EOL>为结束符的。如果你想设置文件以<EOL>结束符结尾，则可以用以下命令：

  ```
  :set endofline
  :set noendofline
  ```

###### 显示换行

- 使用以下命令进入<list mode>，那么就可以清楚的看到以“$”表示的换行符和以“^I”表示的制表符。

  ```
  :set list
  :set nolist
  ```

###### 删除换行

- 可以用以下命令删除换行符：

  ```
  :%s/\n//g
  ```

- 可以用以下命令删除DOS文件中的回车符：

  ```
  :%s/\r//g
  ```

- 可以用以下命令删除DOS文件中的“^M”：

  ```
  :%s/^M//g
  ```

- 可以用以下命令删除行尾的空格以及DOS回车符。它没有使用“/”字符作为替换命令各个参数间的分隔符，而是使用了“#”字符。命令还使用了“\?”正则表达式，用来匹配它前面出现的字符0次或1次。

  ```
  :%s#\s*\r\?$##
  ```

  - 分隔符从/换成了#，里面的\应该表示windows下的格式，然后有一些正则

- 可以用以下命令删除三行空行：

  ```
  :%s/^\n\{3}//
  ```

- 可以用以下命令将连续的两个空行替换成一个空行：

  ```
  :%s/\n\n/\r/g
  ```

###### 自动换行

- 在默认情况下，Vim是不会自动换行的，也就是说我们需要自己决定回车的位置。但是我们也可以通过指定textwidth选项，让Vim自动在指定位置换行。例如，使用以下命令指定在30列时自动换行。由于在遇到空格时才会自动换行，所以换行的精确位置可能会小于你指定的列宽。

  ```
  :set textwidth=29
  ```

- 而以下命令告诉Vim从右面算起当达到10个字符的空格时要换行：

  ```
  :set wrapmargin=10
  ```

- 注意：选项textwidth优先于wrapmargin。如果要使wrapmargin选项生效，必须将textwidth设置为0（这也是默认值）。

- 在指定了文本宽度的情况下，当我们将一行中的前几个文字删掉时，Vim并不会将后面行中的文本移动上来，而是形成了一些长短不一的段落。可以使用以下几种方法来处理这个问题：

  - 一种方法是，在可视化模式下选中这些文本，然后用**gq**命令来格式化选中的段落。
  - 另一种方法是，使用**gqmotion**命令来完成格式。例如**:gq4j**命令，告诉Vim要格式化本行，以及之后的4行，这样就达到了格式化5行的目的。如果要格式化整个段落，可以将光标放在段落的第一行上，然后执行命令**gq}**。而使用命令**gqip**可以格式化当前段落，而且并不必要将光标放在段落的第一行上。如果要想格式化一行，可以使用命令**gqgq**，也可以简记为**gqq**。

###### 合并行

- 命令**J**可以将本行和下一行合并为一行，同时用空格分隔这两行。我们也可以使用数字前缀来合并多行。例如**3J**会将当前行及之后的三行合并为一行。
- 通过设置joinspace选项，可以控制合并两行时的分隔符（如果一行是以标点符号来结尾）。如果设置**:set nojoinspaces**，用J命令合并两行时会用一个空格来分隔；如果设置**:set joinspaces**，用J命令合并两行时会用两个空格来分隔。如果不希望用空格来分隔合并的行，可以使用**gJ**命令。
- 不带参数的**:join**命令，可以将当前行及下一行合并为一行并使用空格来分隔各行。加入范围参数的**:[range]join**命令，可以合并多行。例如**:1,3join**命令，将合并第一到第三行。如果不希望加入空格分隔多行，那么可以使用**:join!**命令。

##### 折行

- 在默认情况下，Vim会自动折行––将超出屏幕范围的文本打断并显示在下一行。我们也可以通过以下命令，取消自动折行––超出屏幕范围的文本将不会被显示，你需要向句末移动光标，以使屏幕水平滚动，查看一行的完整内容。

  ```
  :set nowrap
  ```

  - 这个主要说的是超出屏幕范围的文本打断
  - vim里有个选项是 textwidth，作用就是设置文本宽度，当用户输入一个很长的文本时，如果文本中有空格，那么这行文本就会被 Vim 按照 textwidth 设置的长度自动拆分，拆分成每行最多 textwidth 个字符。它和 Vim 本身的自动折行区别就是，自动折行之后，原来的文字还是一整行，不能用 j k 在折行间切换，只能用 gj gk；而用 textwidth 自动拆分之后，一行文字变成了多行，每行间自动插入了换行符。可以用 j k 在行之间切换。

- 默认设置**set sidescroll=0**之下，当光标到达屏幕边缘时，将自动扩展显示1/2屏幕的文本。过使用**set sidescroll=1**设置，可以实现更加平滑的逐个字符扩展显示。就是相当于默认情况下会显示更多，而设置为1就是如果移动到哪里就显示到哪里

- 可以使用以下命令，恢复Vim的自动折行：

  ```
  :set wrap
  ```

###### 折行形式

- 我们可以告诉Vim在合适的地方折行：

  ```
  :set linebreak
  ```

- 所谓合适的地方，是由*breakat*选项中的字符来确定的。在默认的情况下，这些字符是“^I!@*-+_;:,./?”。如果我们不希望在下划线处打断句子，只要用下面的命令将`“_”`从这个列表移除就可以了：

  ```
  :set breakat-=_
  ```

- 如果一行被打断，Vim可能不会在句子连接处显示任何内容。我们可以通过设置*showbreak*选项，来显示所希望的指示信息：

  ```
  :set showbreak=->
  ```

- 我们可以使用以下命令，取消自定义折行：

  ```
  :set nolinebreak
  ```

###### 在折行内移动

- 如果设置了wrap选项，那么很长的行将被折回并连续显示在屏幕上。但使用j命令，将移动屏幕上显示为多行的一行；而如果希望在折行内向下移动，则需要使用gj或g<Down>命令。同理，gk或g<Up>命令，用于向上移动。

- 在[vimrc配置文件](https://link.zhihu.com/?target=https%3A//bit.ly/vim-vimrc)中，定义以下[键盘映射](https://link.zhihu.com/?target=https%3A//bit.ly/vim-map)，可以使j和k命令自动判断是在折行内或是在折行间进行移动：

  ```
  noremap j (v:count == 0 ? 'gj' : 'j')
  noremap k (v:count == 0 ? 'gk' : 'k')
  ```

##### 拼写检查

- 从版本7开始，Vim内置了拼写检查功能，但是在默认情况下并没有打开。
- 使用:set spell命令打开拼写检查，使用:set nospell命令关闭拼写检查。
- 首先，你需要使用:echo &spelllang命令确认当前使用哪种语言。比如：“en”代表英语。如果想要改语言，可以使用:set spelllang=en_GB.UTF-8命令。也可以用逗号分隔制定检查set spelllang=en_us,nl,medical多种语言。
- 如果在文件中有很多拼写错误，可以用]s命令移动到下一个拼写错误处，用[s命令移动到上一个拼写错误处。
- 如果想要纠正错误的拼写：首先将光标移至错误的单词上，然后执行z=命令列出一组相近的单词，你可以在其中选择正确的拼写。
- 有些特殊单词（比如图中的"Gvim"）也会被标识为错误拼写，如果你希望Vim能够承认它们为正确的拼写，可以使用zg命令。还可以用zw命令取消用户做的拼写识别。

##### 大小写转换

- 命令~可以改变字母的大小写。如果当前光标下的字母为小写，那么点击~可以将该字母转换为大写。同理如果当前光标下的字母为大写，那么点击~则可以将该字母转换为小写。

- tildeop选项可以控制命令~的行为。默认设置下，只会对单个字符进行大小转换。

  ```
  :set notildeop
  ```

- 如果设置了tildeop选项，那么命令就会变为~motion的模式：

  ```
  :set tildeop
  ```

  - 例如，在下面的句子中:this is a test
  - 我们将光标放在第一个t上并执行~ft命令，则结果为：THIS IS A Test
  - 命令使得当前光标以后第一个t和光标间的字符全部转换为大写，如果这个句子中还有小写字符，那么这个命令还可以执行第二次，直到句子中的字符全部为大写为止。

- 可以指定转换字符的个数和方向。例如命令3~l是从当前字符开始向右3个字符进行大小写的转换。

- 命令g~3w可以转换当前光标开始之后的3个单词；而命令g~iw则可以转换当前[inner word](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2016/12/vim-text-objects.html)；而命令g~$则可以转换从当前位置到行尾的所有字符。

- 命令g~g~和g~~可以转换整行的大小写。而且并不依赖于[tildeop](https://link.zhihu.com/?target=http%3A//vimcdoc.sourceforge.net/doc/options.html%23'notildeop')选项的设置。

- 在可视化模式下，可以使用u命令，将选中的字母转换为小写；也可以使用U命令，将选中的字母转换为大写。

- gUU和gUgU命令，都可以将整行字符转换为大写。如果指定了数字参数，例如3gUU则可对指定行数进行转换。

- 相对应的guu和gugu命令，则是用于将整行字符转化为小写。

###### 首字母大写

- 选中文本，然后进入命令行模式并使用以下命令，可以将选中的文本转换为首字母大写（title case / initial capitals）。

  ```
  :s/\<\(\w\)\(\w*\)\>/\u\1\L\2/g
  ```

##### 宏

- 利用键盘宏（Macro），可以录制一组命令，然后重复执行。

  ```
  tansen is the singer
  daswant is the painter
  birbal is the wazir
  例如，我们需要对以上文字，进行下列处理：
  将每行的首字符大写；
  将"is"改为"was"；
  在每行结尾增加 "in Akbar's court."
  显然，手工重复完成这些操作是相当繁琐和费时的，而使用宏则会非常高效。
  
  ```

- 录制宏

  - 进入常规模式；
  - 将光标移动到第一行的第一个字母上；
  - 执行qa命令，开始录制宏a；q 命令是开始录制宏，a是宏名，也可以起其他名字。
  - 执行gUl命令，将首字母转换为大写；
  - 执行w命令，移动到下一单词；
  - 执行cw命令，修改单词；
  - 输入“was”；
  - 点击Esc键，返回常规模式；
  - 执行A命令，在行尾添加文字；
  - 输入“in Akbar's court”；
  - 点击Esc键，返回常规模式；
  - 执行q命令，完成录制宏；

- 查看宏，宏录制的命令序列，将被存储在指定的[寄存器](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-12-Register.html)（Regists）中。使用以下命令，可以查看宏的内容：

  ```
  :register a 
  ```

- 执行宏，在完成一行的修改并录制宏后，就可以使用宏快速完成其它行的处理了：

  ```
  执行j命令，移动到下一行；
  执行0命令，移动到首字母；
  执行@a命令，执行宏a；
  
  我们还可以在执行命令前加上数字，比如3@a，来告诉vi执行几次宏。
  ```

- 删除宏，通过重新录制宏，可以覆盖当前宏的内容。例如，使用`qaq`命令，将清空宏a的内容；使用以下命令，也可以将宏a置为空：

  ```
  :let @a = '' 
  ```

##### 多编码处理

- 在Vim中有四个与编码有关的选项：“fileencodings (fencs)”、“fileencoding (fenc)”、“encoding (enc)”和“termencoding (tenc)”，任何一个选项出现错误，都会导致出现乱码。

- encoding是Vim内部使用的字符编码方式。Vim内部所有的buffer、寄存器、脚本中的字符串等，都会使用encoding设置的编码。如果编码方式与Vim的内部编码不一致，那么会先把编码转换成内部编码。如果编码中含有无法转换为内部编码的字符，那么这些字符就会丢失。因此，在选择Vim内部编码时，一定要使用一种包容力足够强的编码。由于encoding选项涉及到Vim中所有字符的内部表示，因此只能在Vim启动的时候设置一次。在Vim工作过程中修改encoding会造成非常多的问题。

  - 建议将encoding设置为utf-8，同时设置以下选项，以避免在非UTF-8系统（如Windows）下，菜单和系统提示出现乱码：

    ```
    set encoding=utf-8
    set langmenu=zh_CN.UTF-8
    language message zh_CN.UTF-8
    ```

  - 当然，你也可以设置菜单和信息都显示为英文，这样也可以避免Vim程序界面乱码的问题：

    ```
    set langmenu=en_US
    let $LANG = 'en_US'
    source $VIMRUNTIME/delmenu.vim
    source $VIMRUNTIME/menu.vim
    ```

- termencoding是Vim用于屏幕显示的编码。Vim会把内部编码转换为屏幕编码，再用于输出。内部编码中含有无法转换为屏幕编码的字符时，该字符会变成问号，但不会影响对它的编辑操作。如果termencoding没有设置，则直接使用encoding而不进行转换。

  - 例如，你在Windows下通过telnet登录Linux工作站时，由于Windows的telnet是GBK编码的，而Linux则使用UTF-8编码，因此telnet下的Vim中就会乱码。此时有两种消除乱码的方式：你可以将Vim的encoding改为gbk，或者保持encoding为utf-8，而将termencoding改为gbk。显然，使用前一种方法时，如果编辑的文件中含有GBK无法表示的字符时，这些字符就会丢失。但如果使用后一种方法，虽然由于终端所限，这些字符无法显示，但在编辑过程中这些字符并不会丢失。

  - 你可以利用以下命令设置termencoding：

    ```
    set termencoding=utf-8
    ```

- 当Vim从磁盘上读取文件时，会对文件编码进行探测。如果文件的编码方式和Vim的内部编码方式不同，Vim就会对编码进行转换。转换完毕后，Vim会将fileencoding选项设置为文件的编码。当Vim存盘时，如果encoding和fileencoding不一致，Vim就会进行编码转换。因此，通过打开文件后设置fileencoding，可以将文件由一种编码转换为另一种编码。

  ```
  set fileencoding=utf-8
  ```

  - 注意：因为Vim是在打开文件时，自动探测和设置fileencoding的，所以，如果出现乱码，就无法通过在打开文件后重新设置fileencoding来纠正乱码。

- 编码的自动识别，是通过设置fileencodings实现的。fileencodings是一个用逗号分隔的列表，列表中的每一项是一种编码的名称。当我们打开文件时，Vim按顺序使用fileencodings中的编码进行尝试解码，如果成功的话，就使用该编码方式进行解码，并将fileencoding设置为这个值；如果失败的话，就继续检验下一个编码。因此，我们在设置fileencodings时，一定要把严格的编码方式放在前面，把宽松的编码方式放在后面。例如，latin1是一种非常宽松的编码方式，任何一种编码方式得到的文本，用latin1进行解码，都不会发生解码失败。当然，解码得到的结果也很可能会是乱码。因此，如果你把latin1放到fileencodings的第一位，那么打开任何中文文件都会显示乱码了。推荐使用以下fileencodings设置：

  ```
  set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,latin1
  ```

  - 其中， ucs-bom 是一种非常严格的编码，非该编码的文件几乎没有可能被误判为ucs-bom，因此放在第一位。utf-8也相当严格，除了很短的文件之外也是几乎不可能被误判的，因此放在第二位。接下来是 cp936、gb18030、big5 这些编码相对宽松的编码。 而最为宽松的 latin1 编码，则放在列表的最后。
  - 如果编码被误判了，解码后的结果就会显示为无法识别的乱码了。此时，如果你知道这个文件的正确编码，可以把fileencodings改成只有这一种编码，阻止任何 fall-back 发生，然后重新打开这个文件。

###### 编码转换

- 当我们看到类似“&#24573;&#28982;”的编码时，可以通过以下命令将&#后的数字，经由函数nr2char()转换为可读的文字：

  ```
  :%s/&#\([0-9]\+\);/\=nr2char(submatch(1))/g
  ```

### 多文件操作

##### 参数

###### 启动参数

- 在启动vim时，可以指定多个文件做为参数，例如以下操作系统命令将打开多个文件，并显示第一个文件：

  ```
  vim file1.txt file2.txt file3.txt
  ```

- 参数（Arguments）和[缓冲区（Buffer）](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)是不同的概念。早在Vi之中，就存在参数概念；而缓冲区则是在Vim之中新引进的。参数列表中的所有文件名，都会同时存在于缓冲区列表之中；但并不是所有缓冲区列表中的文件名，也都会出现在参数列表之中。

  - 例如在启动vim之后，我们使用以下命令打开并编辑文件4：

    ```
    :e file4.txt
    ```

  - 此时显示三个参数，缓冲区有四个文件

###### 参数列表

- 命令`:args`可以列示打开的多个文件，并用中括号“[]”标识出正在编辑的文件名。

###### 切换多个文件

- 可以使用:argument命令，直接切换到指定的文件。例如以下命令，将切换至列表中的第三个文件：

  ```
  :argument 3
  ```

- 需要切换到下一个文件时，可以输入`:next`命令，如果你没有保存当前文件的修改，vim将给出提示信息，不允许切换到下一文件。输入`:write`和`:next`命令，则可以保存并切换到第二个文件（此命令也可简写为`:wnext`）。

- 使用`:next!`命令，可以强制切换到第二个文件，但所做改动也将会丢失。使用`:set autowrite`命令打开自动保存功能，可以避免数据丢失的意外情况；而命令`:set noautowrite`则可以关闭自动保存功能。

- 如果想要回到上一个文件，可以使用`:previous`或是`:Next`命令。如果要保存当前文件并切换到前一文件，可以使用`:wprevious`或是`:wNext`命令。

- 使用快捷键**ctrl+^**可以快速切换到上一个文件，以实现在#（current filename）和 %（alternate filename）文件之间快速切换的目的。

- 使用`:first`或`:rewind`命令，可以快速切换到第一个文件；而`:last`命令，则可以快速切换到最后一个文件。

##### 窗口

- 窗口（Window）用来查看[缓冲区](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)（Buffer）的内容。你可以用多个窗口查看同一个缓冲区，也可以用多个窗口查看不同的缓冲区。利用多窗口，我们就能够很方便地对比多个文件，在不同文件之间复制粘贴或者查看同一文件的不同部分。

- Vim主窗口可以容纳多个分割的窗口。也可以创建多个[标签页](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-15-Tabs.html)（tab-page），每个标签页也能容纳多个窗口。窗口的分割是在原来的窗口上分割成多个，而创建标签页是新增加一个窗口

- 在默认情况下，与Vi类似，Vim启动后只打开一个窗口。参数 "-o" 和 "-O" 可以让Vim为参数列表里的每一个文件打开一个窗口。参数 "-o" 水平分割窗口；参数 "-O" 垂直分割窗口。如果 "-o" 和 "-O" 都用了，那么最后一个参数决定分割的方向。例如，下面的例子打开三个水平分割的窗口。

  ```
  vim -o file1 file2 file3
  ```

###### 分割窗口

- `:split`命令，会将当前窗口水平分为两个，并且在这两个窗口中同时显示当前文件。如果你在其中一个窗口进行编辑，那么另一个窗口也会同步显示出你所做的更改。
- 默认情况下，每一个窗口都是独立滚动的。所以在编辑很长文档的时候，我们可以在不同窗口显示同一文档的不同部分。例如：一个窗口显示目录，另一个窗口显示正文。我们也可以使用`:set scrollbind`命令，绑定不同的窗口同步滚动。
- 如果想要在两个窗口中编辑不同的两个文件。使用`:split file`命令，就可以在另一个窗口中打开文件file了。
- 相对应的`:vsplit`命令，用于垂直分割窗口。
- 命令`:new`可以直接水平打开一个新窗口，并对新文件进行编辑。
- 相对应的`:vnew`命令，用于垂直分割窗口并编辑新文件。
- `:sview`是:split和:view两个命令的组合，它可以分隔出一个新窗口，并以只读方式打开指定的文件。

###### 切换窗口

- 在gvim和vim中，使用命令`:set mouse=a`启用鼠标支持，就可以通过点击鼠标来进入不同的窗口。

- 你也可以使用以下ctrl+W快捷键在多个窗口中进行切换：

  ![](https://pic1.zhimg.com/80/v2-736a8a62c30686cf405ac0b8b14dc540_1440w.jpg)



###### 移动窗口

- 命令ctrl+Wx，可以将当前窗口与下一窗口进行位置对换。如果当前窗口在底部，则没有下一个窗口，这时命令将当前窗口与上一个窗口进行位置对换。

- 命令ctrl+Wr命令可以使得窗口向右或向下进行循环移动。这个命令可以带一个数字作为参数，指明向下循环移动所执行的次数。与其相类似的ctrl+WR命令，可以使得窗口向左或向上循环移动。

- 以上命令在调换窗口位置时，会维持现有的窗口尺寸和布局；而以下命令，则会同时改变窗口的位置、尺寸和布局：

  ![](https://pic1.zhimg.com/80/v2-73497e5d9aa807abb6af9191f4696f44_1440w.jpg)

###### 控制窗口尺寸

- 在输入:split命令时，可以加入参数来指定打开窗口的大小。例如命令`:3 split file`，将在一个大小为三行的新窗口中打开文件file。我们也可以将这个命令中的空格去掉，写成`:3split file`。
- 使用ctrl+W+命令增大窗口高度，默认增量为1行；ctrl+W-命令减小窗口高度，默认值为1行。命令countCtrl+W_可以使得当前窗口变为count指定的高度；如果没有指定count，则将当前窗口变得尽可能最大。
- 使用`:resize`命令，可以精确控制窗口高度。例如：`:resize +3`将增大窗口高度3行；`:resize -3`将减少窗口高度3行；`:resize 3`则将精确指定窗口高度为3行。
- 命令ctrl+W=可以将几个窗口的大小变为相等。
- 使用ctrl+W>命令增大窗口宽带，默认增量为1列；ctrl+W<命令减小窗口宽度，默认值为1列。命令countCtrl+W|可以使得当前窗口变为count指定的宽度；如果没有指定count，则将当前窗口变得尽可能最大。
- 使用`:vertical resize`命令，可以精确控制窗口宽度。例如：`:vertical resize +3`将增大窗口宽度3列；`:vertical resize -3`将减少窗口宽度3列；`:vertical resize 3`则将精确指定窗口宽度为3列。

###### 关闭窗口

![](https://pic3.zhimg.com/80/v2-75b9b0ce55609d583351064390d2f672_1440w.jpg)

- only命令表示只显示当前窗口，关闭所有其他窗口

- 使用`:help CTRL-W`命令可以，查看关于窗口操作的帮助信息。

##### 缓冲区

- 缓冲区（Buffer）是一块内存区域，用于存储着正在编辑的文件。在保存缓冲区并退出时，内容也随之被写回原始文件。
- 上面中的窗口可以打开的是同一个缓冲区，每一个文件都是一个缓冲区，所以在一个窗口上修改另一个窗口上也会修改

###### 增加缓冲区

- 在启动vi时，可以指定多个文件做为参数，例如`vi file1 file2 file3`，参数中的所有文件都会被载入缓冲区，但vi只会在窗口中显示第一个文件。你可以使用以下命令，为每一个缓冲区打开一个窗口。

  ```
  :ball
  ```

- 使用`:badd filename`命令将新增一个缓冲区。指定的文件会被加载到缓冲区列表中，但是对这个文件的编辑过程只有切换到那个缓冲区时才会开始。在命令中，还可以指明为这个缓冲区打开窗口时，光标所处的位置：

  ```
  :badd +linenum filename
  ```

###### 列示缓冲区

- `:buffers`，`:files`和`:ls`命令将会列出当前编辑中的（除“u”类型之外）缓冲区信息。在列表中，第一个数字是缓冲区的标号；第二个标记是缓冲区当前的状态；紧接着是与缓冲区所关联的文件名。

  ![](https://pic1.zhimg.com/80/v2-78f1f26e45389c109e7ae263c250dc54_1440w.jpg)

<img src="https://pic3.zhimg.com/80/v2-284012052944f35750a0e6834d5eb886_1440w.jpg" style="zoom:50%;" />

- 使用“!”修饰符的`:buffers!`，`:files!`和`:ls!`命令将会列出包括“u”类型在内的所有缓冲区信息。如下图所示，窗口中使用`:help buffers`命令查询帮助信息，而`:buffers!`命令则列示了其打开windows.txt文件的“u”类型缓冲区。

###### 选择缓冲区

- 可以使用number参数，选择指定标号的缓冲区：

  ```
  :buffer number
  ```

- 也可以使用文件名来选择缓冲区：

  ```
  :buffer filename
  ```

- 我们可以用`:sbuffer number`命令，来分割当前窗口开始编辑一个缓冲区。如果指明了数字，那么当前窗口就会显示数字所标记的缓冲区中的内容；如果没有指明数字，那么就会显示当前缓冲区的内容。当然，这个命令也可以用文件名来做为参数：相当于在当前窗口下分割了一个窗口来编辑缓冲区，相当于先增加了一个窗口然后使用e命令增加一个

  ```
  sbuffer filename
  ```

###### 切换缓冲区

- `:bnext`到下一个缓冲区；`:bprevious`或`:bNext`到前一个缓冲区；`:blast`到最后一个缓冲区；`:bfirst`到第一个缓冲区。
- 根据默认设置，在切换到另一缓冲区之前，Vim将提示你保存当前缓冲区。你也可以使用`:set hidden`命令，允许在未保存的情况下切换缓冲区。

###### 删除缓冲区

- 可以使用`:bdelete filename`，`:bdelete 3`或`:3 bdelete`命令来删除一个缓冲区。也可以使用`:1,3 bdelete`命令来删除指定范围的缓冲区。所删除缓冲区引用的文件名，也将会随之从缓冲区列表中删除。
- 如果缓冲区被改动过，那么该命令将失败。如果使用了!选项的`:bdelete! filename`命令，强制删除缓冲区，那么在缓冲区中的所有改动都会被放弃。

###### 删除所有缓冲区

```
%bdelete       " delete all buffers
可以简写为%bd
```

- 上述命令为删除所有的缓冲区

```
e[dit] [++opt] [+cmd] #[count]
                        Edit the [count]th buffer (as shown by |:files|).
                        This command does the same as [count] CTRL-^.  But ":e
                        #" doesn't work if the alternate buffer doesn't have a
                        file name, while CTRL-^ still works then.
                        Also see |++opt| and |+cmd|.
```

- 上述命令edit表明e #后面跟具体的数字表示编辑第几个buffer，e#和e #作用一样，加不加空格都是一样的，如果e#不加数字表示是当前的buffer
  - 直接输入命令e不带参数表示编辑当前文件，如果文件在vim外面被其他软件更改之后，这个很有用，可以直接重新编辑当前文件

- 在vim中｜字符是用来在一条语句里面执行多个命令的，所以我们可以将多条语句写成一行。这个不要跟c语言中的或扯上关系，两个是不同的东西。

```
%bd | e#
```

- 工作流程为：关闭所有打开的缓冲区，然后重新打开我当前所在的缓冲区. 在 Vim 中， `|` 将命令的执行链接在一起。

```
noremap bo :%bd \| e# \| bd#<cr>
```

- 键盘映射是写在vimrc中的，和命令行模式下的执行命令不太一样，所以要用\反斜杠转义，即如果命令行中执行就没有反斜杠。
- 缓冲区中的#表示交换缓冲区，即上一个缓冲区切换过来的那个缓冲区就是交换缓冲区，前面用#表示。
- 在%bd删除所有缓冲区的时候，会生成一个[No Name]的交换缓冲区，所以最后要用bd#来删除这个交换缓冲区。

###### 卸载缓冲区

- 命令`:bunload`会从内存中卸载一个缓冲区，所有为这个缓冲区打开的窗口也会关闭。但是这个文件名仍然会存在于缓冲区列表中。如果缓冲区被改动过，那么该命令将失败。你也可以使用!选项的`:bunload!`命令，强制卸载缓冲区，但所有的改动也将会丢失。
- 可以使用`:help buffers`命令，查看关于缓冲区的帮助信息。

##### 多标签页

- Vim 7.0开始引入了多标签页（Tabs）概念，用于同时编辑多个文件，每一个标签页也可以包含多个缓冲区或窗口。标签页的特殊之处在于，通常作用于所有打开的缓冲区和窗口的命令（比如 :bufdo, :windo, :all, and :ball等），将只影响当前标签页中的缓冲区和窗口。

###### 新建标签页

- 使用**:tabedit**命令和文件名参数，可以在新标签页中打开指定的文件。也可以使用**:tabnew**命令，在新标签页中编辑新的文件。在输入以上命令及空格键之后，点击Tab键，将显示当前目录下的文件列表以方便你输入文件名称。

- 命令**:tab split**将保留当前标签页，并在新标签页中打开当前缓冲区中的文件。如果你使用**:sp filename.txt**命令，在当前标签页中创建了一个新窗口；那么点击**Ctrl-WT**快捷键，将在当前标签页中关闭该文件，并在新建标签页中打开该文件。

- 如果你打开了多个缓冲区，那么使用命令**:tab ball**将为每一个打开的缓冲区，分别新建单独的标签页。

- Vim默认最多只能打开10个标签页。你可以用**set tabpagemax=15**改变这个限制。

- Tab的标签默认显示当前缓冲区的文件名。如果在同一标签页中打开了多个缓冲区，那么标签也会显示打开缓冲区的总共数目。"+" 表示已经修改过的页面。而"2+" 则表示有3个窗口，其中一个已经更改。

- 命令**:tabfind**允许你搜索并在新标签页中打开文件。比如我想打开当前目录下的img.txt文件，那么就可以使用**:tabfind img.\***命令。请注意，此命令只能打开一个文件，如果搜索出多个匹配文件，将提示“E77: 文件名过多”，这时你需要给出更精确的搜索条件以打开文件。此命令搜索文件的范围，是由path选项指定的。例如以下命令将指定搜索包含当前文件的目录（.），当前目录（两个逗号之间的空格）, 以及当前目录下的所有子目录（**）：

  ```
  :set path=.,,**
  ```

###### 列示标签页

- 命令**:tabs**可以显示已打开标签页的列表，并用“>”标识出当前页面，用“+”标识出已更改的页面。

###### 关闭标签页

- 命令**:tabclose**可以关闭当前标签页。而命令**:tabonly**将仅保留当前标签页，而关闭其它所有的标签页。
- 如果你使用Ctrl-Wc快捷键，关闭了当前标签页中的最后一个窗口，那么当前标签页也会随之关闭。

###### 切换标签页

- 使用以下任一命令，可以移动到下一个标签页：
  - **:tabn**
  - **gt**
  - **Ctrl-PgDn**
- 使用以下任一命令，可以移动到上一个标签页：
  - **:tabp**
  - **gT**
  - **Ctrl-PgUp**
- 这里面还有好多命令是移动到上一个和下一个例如+tabnext
- 如果你打开了很多标签页，那么可以使用**:tabfirs**t或**:tabr**命令，移动到第一个标签页。使用**:tablast**命令，移动到最后一个标签页。

###### 移动标签页

- 如果你希望按照指定的次序排列标签页，那么你可以使用**:tabm**命令。请注意，标签页次序是从0开始计数的。比如命令:tabm 1将把当前标签页移动到第2的位置。如果你没有为:tabm命令指定参数，那么当前标签页将会被移动到最后。

###### 配置标签页

- 默认情况下，只有用户新建了标签页才会在窗口上方显示标签栏，这是由选项**set showtabline=1**决定的。如果我们希望总是显示标签栏，那么可以用**set showtabline=2**命令来设置。如果我们希望完全不显示标签栏，那么可以使用**set showtabline=0**来设置。

###### 多标签页命令

- 使用**:tabdo**命令，我们可以同时在多个标签页中执行命令。比如我们打开了多个标签页，需要把这些文件中的“food”都替换成“drink”，那么就可以使用**:tabdo %s/food/drink/g**命令，一次完成对所有文件的替换操作，而不用针对每个文件重复操作。

##### 编辑多个文件

- 如果需要同时打开并编辑多个文件，可以使用以下几种方法：

  - 在启动vim时，可以指定多个文件做为**[参数(Argument)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-16-MultiArguments.html)**以同时打开多个文件；

  - 在Vim中，新建**[窗口(Window)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-14-MultiWindows.html)**用于打开文件；

  - 在Vim中，在任一窗口(Window)内，都可以新建多个**[缓冲区(Buffer)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)**用于编辑不同的文件。

    <img src="https://pic1.zhimg.com/80/v2-e52b813d144f137913928613187de954_1440w.jpg" style="zoom:50%;" />

<img src="https://pic4.zhimg.com/80/v2-449fd009b819bdc1df7285eb49d35fab_1440w.jpg" style="zoom:50%;" />

###### 在不同文件拷贝内容

- 使用[标记](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-53-Mark.html)，在不同文件之间拷贝文本：
  - 编辑第一文件
  - 执行命令`:split second_file`打开另一个窗口并开始编辑第二个文件
  - 使用命令`ctrl+Wp`回到含有原始文件的前一个窗口
  - 将光标移动到要拷贝文本的第一行
  - 用命令`ma`标记这一行
  - 移动到要拷贝文本的最后一行
  - 执行命令`y'a`来复制当前光标位置到所做标记之间的文本
  - 使用命令`ctrl+Wp`回到将要放置文本的文件
  - 将光标移到将要插入文本的地方
  - 使用命令`P`将复制的文本粘贴到文件中
- 使用可视化模式，在不同文件之间拷贝文本：
  - 编辑第一文件
  - 执行命令`:split second_file`打开另一个窗口并开始编辑第二个文件
  - 使用命令`ctrl+Wp`回到含有原始文件的前一个窗口
  - 将光标移动到要拷贝文本的第一行
  - 执行命令`V`进入可视化模式
  - 移动到将要复制文本的最后一行，被选中的文本将会被高亮显示
  - 执行命令`y`复制选中的文本
  - 使用命令`ctrl+Wp`回到将要放置文本的文件
  - 使用命令`P`将复制的文本粘贴到文件中
- 使用[寄存器](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-12-Register.html)，在不同文件之间拷贝文本：
  - 编辑第一文件
  - 执行命令`:split second_file`打开另一个窗口并开始编辑第二个文件
  - 使用命令`ctrl+Wp`回到含有原始文件的前一个窗口
  - 将光标移动到要拷贝文本的第一行
  - 执行命令`"a3yy`将需要复制的行放入寄存器
  - 使用命令`ctrl+Wp`回到将要放置文本的文件
  - 使用命令`"ap`将复制的文本粘贴到文件中

###### 读入文件

- 使用`:read filename`（可简写为`:r`）命令，可读进一个文件并将内容插在当前行的后面。我们也可以在命令中，指明读取内容放置在文件中的特定位置。例如`:0r filename`命令，将读取内容放置在文件开头；而`:$r filename`命令，则会将读取内容放置在文件末尾。

###### 写入文件

- 命令`:write`（可简写为`:w`）用来写入文件（也就是保存当前文件）。

- 使用以下命令将保存文本到文件collect.txt中：

  ```
  :write collect.txt
  ```

- 如果这个文件已经存在，那么就会显示错误信息。如果要强行保存，那么需要使用!选项：

  ```
  :write! collect.txt
  ```

- 我们也可以向已有文件中追加内容。使用以下命令将正编辑的文件内容追加到collect.txt中:

  ```
  :write >> collect.txt
  ```

- 使用以下命令，将正编辑的文件的部分内容（第100行到文件末尾）追加到collect.txt中:

  ```
  :100,$write >> collect.txt
  ```

- 如果这个文件不存在，那么就会显示错误信息。可以使用!选项，强行创建并保存新文件：

  ```
  :write! >> collect.txt
  ```

- 我们还可以导出文件中的部分内容到其它文件中，以达到分拆文件的目的。以下命令将第10行到文件末尾的内容保存到collect.txt中：

  ```
  :10,$write collect.txt
  ```

- 以下命令则会将当前行到第100行的内容保存到collect.txt中：

  ```
  :.,100write collect.txt
  ```

- 在可视化模式下，选择内容，然后使用以下命令也可以写入其它文件：

  ```
  :'<,'> write collect.txt
  ```

- 命令`:wall`可以保存所有已经修改过的文件（包括隐藏缓冲区中的文件）。

###### 退出文件

- `:quit`可以退出当前文件。而`:qall`命令，则可以退出所有打开的文件。

- 如果文件已修改但没有保存，则会在窗口底部显示警告信息并禁止退出。可以使用以下命令，配置Vinm在此类情况下显示确认对话框：

  ```
  :set confirm
  ```

- 如果想要放弃所做的修改并强行退出，可以使用`:qall!`命令。

- 使用命令`:wqall`组合，可以保存所有文件并退出。

##### 比较文件

- Vim通过调用外部的diff命令，可以对相似的文件进行比较。使用`:help diff`命令，可以查看关于比较文件的更多信息。

- 为了避免[配色方案](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-62-ColorScheme.html)对比较结果显示效果的影响，我们可以在[vimrc配置文件](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)中，增加以下命令，以便在比较文件时使用默认的显示颜色：

  ```
  au FilterWritePre * if &diff | colorscheme default | endif
  if &diff
  	 colorscheme default
  endif
  ```

###### 比较

- 可以从命令行调用以下命令，来打开两个文件进行比较：

  ```
  vim -d file1 file2
  ```

- 如果已经打开了文件file1，那么可以在Vim中用以下命令，再打开另一个文件file2进行比较：

  ```
  :diffsplit file2
  ```

- 如果已经使用split打开了两个文件，那么可以分别在两个窗口里面输入以下命令，进行比较：

  ```
  :diffthis
  ```

- 屏幕将被水平分隔，分别显示一个文件，其中不同的部分将被高亮显示。

  - 只在某一文件中存在的行，显示为蓝色；
  - 而在另一文件中的对应位置的行，显示为绿色；
  - 在两个文件中都存在的行，显示为紫色
  - 行中不相同的字符，显示为红色；
  - 相同的行，没有高亮显示并且会被折叠。

- 如果想要垂直比较两个文件，可以使用以下命令：

  ```
  :vert diffsplit file2
  ```

  ![](https://pic2.zhimg.com/80/v2-acc692ec7e180642615def68c689c54d_1440w.jpg)

###### 折叠

- 使用`zo`命令，可以展开被折叠的相同的文本行；而`zc`命令，则可以重新折叠相同的行。

###### 查看

- 比较文件时，经常需要结合上下文来确定最终要采取的操作。缺省情况下，是会把不同之处上下各6行的文本显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数为3行，可以使用以下命令：

  ```
  :set diffopt=context:3
  ```

###### 滚动

- 如果你在一个文件中滚动屏幕，那么另一个文件也会自动滚动以显示相同的位置。你可以使用以下命令，取消联动：

  ```
  :set noscrollbind
  ```

- 使用以下命令，将重新绑定联动：

  ```
  :set scrollbind
  ```

- 利用以下命令，可以定义滚动方式：

  ```
  :set scrollopt ver,hor,jump
  ```

  - 其中：选项*ver* ，启用垂直同步滚动；选项*hor* ，启用水平同步滚动；而*jump* 选项，则在切换窗口时，使垂直滚动始终同步。

- 如果光标停留在两个文件的不同位置，那么可以使用下面的命令同步滚动：

  ```
  :syncbind
  ```

###### 更新

- 如果更改了某个文件的内容，vim又没有自动更新diff检查，那么可以使用如下命令更新：

  ```
  :diffupdate
  ```

###### 跳转

- 你可以用`[c`命令；跳转到前一个不同点；或者用`]c`命令，跳转到后一个不同点。

##### 操作文件

- 使用`:Explore`命令（注意开头E大写）打开文件浏览器，可以在其中切换目录并选择打开文件。

  - 使用键盘移动光标至文件或文件夹名称上，然后点击**Enter**回车键，可以在当前窗口中打开该文件或文件夹；如果希望在新建窗口中打开文件或文件夹，那么可以点击**o**键。

  - 直接使用鼠标点击文件或文件夹名称，也可以在当前窗口中打开该文件或文件夹。

  - 点击大写**R**键，然后修改窗口底部信息中的第二个文件名，可以重命名当前光标下的文件。

    ![](https://pic3.zhimg.com/80/v2-3a9e2283370ccd508378ff850e060346_1440w.jpg)

  - 点击大写**D**键，然后在窗口底部信息中进行确认，则可以删除当前光标下的文件。

    ![](https://pic2.zhimg.com/80/v2-0535b80bccfd9149c1c89360e03b5f41_1440w.jpg)

  - 点击**/**键，可以在文件列表中进行查找。

- ：Sex水平分割一个窗口，浏览文件系统，：Vex垂直分割一个窗口，浏览文件系统

###### goto file

- 如果当前文件中包含了其他文件名，那么我们可以移动到文件名位置，然后直接使用`gf`命令在新的[缓冲区](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2009/07/vim-buffer.html)中打开链接的文件。例如下图所示，在HTML文件中引用了CSS文件，那么只需要在CSS文件名处执行gf命令，Vim就会在当前文件夹中查找并打开引用的CSS文件。gd命令跳至当前光标所在的变量声明处。

  ![](https://pic4.zhimg.com/80/v2-b9d83529635ab30c04abf461ab21e69f_1440w.jpg)

- 如果文件名中没有指明扩展名称，那么可以使用以下命令来指定gf需要查找的文件类型：

  ```
  :set suffixesadd+=.rb
  ```

- 如果我们希望gf在多个文件夹中尝试查找并打开文件，那么可以使用以下命令来定义文件夹列表：

  ```vim
  :set path+=D:/Anthony_GitHub/learn-vim/**
  ```

- 使用以下命令可以查看当前path选项的设置：

  ```vim
  :set path?
  ```

  - 其中，“.”代表当前文件夹下的所有文件；“**”代表所有子文件夹；“,”用于分隔多个文件夹。

- 我们也可以使用`ctrl-Wf`命令，在新的分割窗口中打开光标下文件。

###### 文件信息

- 使用以下命令，可以显示当前文件的名字、状态以及行列相关的信息：

  ```vim
  :file
  ```

- 使用以下命令，则可以显示当前文件的总行数：

  ```vim
  := 
  ```

- 使用`g-Ctrl-g`命令，将在状态栏下方显示整个文档的字数和行数，以及当前所处的位置。

- 如果想要统计当前行的字数，首先移动到行尾，然后使用`v`命令进入可视化模式，使用`0`命令移动到行头并选中整行文字，最后使用`g-Ctrl-g`命令显示选中文本的字数。

- 在插入模式下，使用`<C-R>%`命令，或者在常规模式下，使用`"%p`命令，可以将当前文件名粘贴到文本中。

- 使用以下命令，可以在文本中查找当前文件名：

  ```vim
  /<C-R>%   这个命令中的c-R是在命令行模式下直接按组合键c-R
  ```

###### 查看文件

- 使用`:view file`命令，将以只读方式打开文件。
- 使用`:set ro`命令，会将当前文件置为只读状态。你在文件中进行的任何修改，都无法保存。当然我们也可以使用`:write!`命令，来强制保存文件。
- 使用`:set noma`命令，可以将当前文件置为不可修改状态，Vim会阻止任何修改操作。

###### 新建文件

- 使用`:vi file`命令，在新建缓冲区中编辑名为file的新文件。如果当前文件没有保存，那么将会显示警告信息，此时可以输入`:write`命令，来保存当前文件。
- 使用`:vi! file`命令，将不保存当前文件而强制开始编辑新文件。

###### 另存文件

- 使用以下命令，可以将当前文件另存为以name命名的新文件，并在当前缓冲区中开始编辑新文件：

  ```vim
  :file name
  ```

###### 工作目录

- 使用以下命令，可以查看Vim所在的当前工作目录:

  ```vim
  :pwd
  ```

###### 切换目录

- 如果想要切换到其它目录，可以使用以下命令:

  ```vim
  :cd dir
  ```

  - 注意：如果没有指定目录，那么使用`:cd`命令，在Linux下，将回到home用户主目录；而在Windows下，则会显示当前工作目录。

- 如果想要回到前一个工作目录，可以使用以下命令:

  ```vim
  :cd - 
  ```

- 使用以下命令，可以返回上一级目录：

  ```
  :cd ..
  ```

  我们还可以使用以下命令，创建新的目录:

  ```
  :!mkdir my_project
  ```

###### 利用wildmenu选择目录

- 在vimrc配置文件中，增加以下两条命令，可以在屏幕底部启用wildmenu菜单显示：

  ```
  set wildmenu
  set wildmode=list:longest,full
  ```

  - 启用wildmenu菜单之后，在命令行中，第一次点击Tab时， 将列示所有可能与已输入字符相匹配的命令列表；第二次点击Tab时，则将在显示的wildmenu中遍历匹配项；然后点击回车键做出选择。

- 在命令行中输入`:e`命令，紧接着输入一个空格，然后点击Tab键，将在屏幕底部的wildmenu中，显示当前目录下的子目录和文件列表：

  - 再次点击Tab键，可以选择下一个项目，点击Shift + Tab键则可以选择上一个项目 ；使用左右移动键，也可以在文件列表中进行选择；而使用上下移动键，则可以移动至上一层或下一层目录。点击回车键，将打开选中的文件或文件夹。
  - 如果在命令行中输入`:e`命令，紧接着输入一个空格以及文件名的开头部分，然后点击Tab键，那么将在屏幕底部的wildmenu中显示与之相匹配的项目；如果只发现一个匹配项，那么将会直接补全文件名：

##### 比较文件消除差异

- 在操作系统的命令行中使用以下命令，可以利用Vim比较多个文件：

  ```vim
  $ vimdiff file1 file2
  ```

  - 这个是在shell中输入

- 如下图所示，红色高亮区域显示了两个文件中第三行的差异，左侧文件包含文字“ACTUAL”，而右侧文件则包含文字“BUDGET”：

  <img src="https://pic2.zhimg.com/80/v2-6eaba2b266495d3c145bfbe4909721cd_1440w.jpg" style="zoom:50%;" />

- 在比较文件并发现不同之处以后，可以通过命令消除这些差异点。

- 使用`]c`命令，可以移动到差异处。

- 使用`:diffget`或`do`命令，将从另一文件中获得差异文字并复制到当前文件中，以消除差异。

- 例如，在左侧文件中执行:diffget命令，会将右侧文件中的文字“BUDGET”，复制到左侧文件，并替代掉差异文字“ACTUAL”：

- 如果希望一次性获取整个文件的差异，那么可以使用以下命令：

  ```
  :%diffget
  ```

###### 推送差异

- 使用`:diffput`或`dp`命令，将以当前文件为基准，消除另一文件中的差异。

- 例如，在左侧文件中执行:diffput命令，会将左侧文件中的文字“ACTUAL”推送到右侧文件，并替代掉差异文字“BUDGET”：

- 如果希望一次性推送整个文件的差异，那么可以使用以下命令：

  ```
  :%diffput
  ```

- 使用:diffget和:diffput命令消除差异之后，vim会自动刷新差异的高亮显示；如果您采用手动修改文字来消除差异，那么需要执行`:diffupdate`命令来刷新差异的高亮显示。

###### 消除多个文件的差异

- 我们可以同时比较多个文件之间的差异。例如以下命令，将比较三个文件：

  ```vim
  $ vimdiff file1 file2 file3
  ```

- 因为此时打开了多个[缓冲区 (Buffer)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)，所以需要执行:diffget [bufspec]和:diffput [bufspec]命令以指明缓冲区。例如`:diffput 3`命令，将推送差异到第三缓冲区：

- 其中，[bufspec]参数可以是缓冲区编号，缓冲区名称，或者缓冲区名称的一部分。可以使用`:buffers`命令，来查看包含缓冲区编号和名称的列表。

- 使用`:help copy-diffs`命令，可以查看合并/消除差异的更多帮助信息。

### 自定义系统

##### 设置选项

- Vim是一个高度可定制的编辑器，我们可以使用 :set 命令来设置大量的选项，其大致可分为三种：布尔值选项、数值选项和字符串选项。

- 使用以下命令，可以列示所有选项：

  ```vim
  :set all
  ```

- 如果希望查看某个选项的当前值，那么可以使用 :set option? 命令，其返回值将显示在屏幕底部。例如：

  ```vim
  :set list?
  ```

- 使用以下命令，可以设置布尔值选项：

  <img src="https://pic1.zhimg.com/80/v2-dc8bcf92d56add33a5457e116cf0a778_1440w.jpg" style="zoom:50%;" />
  - 如果顺序执行这些命令，那么选项变化如下图所示：

    ![](https://pic3.zhimg.com/80/v2-2a6254a40592ce5770eb6ff7060feb9a_1440w.jpg)

- 使用以下命令，可以设置数值选项：

  <img src="https://pic2.zhimg.com/80/v2-e2f881223f4d95eb2867e659a2262a75_1440w.jpg" style="zoom:50%;" />
  - 如果顺序执行这些命令，那么选项变化如下图所示：

    ![](https://pic4.zhimg.com/80/v2-047d271e569936b73d58ff16b90894bb_1440w.jpg)

- 使用以下命令，可以设置字符串选项：

  <img src="https://pic3.zhimg.com/80/v2-b0eb2b661ad4ea18d662e8cac68a282a_1440w.jpg" style="zoom:50%;" />
  - 如果顺序执行这些命令，那么选项变化如下图所示：

    ![](https://pic1.zhimg.com/80/v2-475b24bc7ce148010907b99d220229d8_1440w.jpg)

- 我们可以在一行:set命令中，设置多个选项。例如以下命令，将设置三个不同的选项：

  ```
  :set list shiftwidth=4 incsearch
  ```

- 使用以下命令，可以将所有的选项都重置为默认值：

  ```vim
  :set all&
  ```

- 使用以下命令，将列示出所有与其默认值不同的选项：

  ```vim
  :set
  ```

##### 键盘映射

- 使用:map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：

  ```text
  :map <F5> i{ea}<Esc>
  ```

  - 其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。

- 使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：

  ![](https://pic1.zhimg.com/80/v2-53b70b061cc2f5fa4c496ac15fef89b4_1440w.png)
  - Operator-pending模式，是指当你输入操作符（比如d）时，然后继续输入的移动步长和文本对象（dw）的状态。

  - 第一列命令定义的映射，仍然可以被重新映射；第二列命令（包含noremap）定义的映射，是不可以被重新映射的。

    ```
    COMMANDS                                  MODES
                                              Visual    Select
    :vmap  :vnoremap  :vunmap  :vmapclear       yes      yes
    :xmap  :xnoremap  :xunmap  :xmapclear       yes       -
    :smap  :snoremap  :sunmap  :smapclear       -        yes
    ```

    

- map系列命令常见的语法如下：

  ```
  [nore]map [<args>] {lhs} {rhs}
  ```

  - `<args>` 表示map命令的一些参数，其中常用的有

  - - `<buffer>` 表示这个映射只是在当前的buffer中定义，而不是定义全局的映射
    - `<expr>` 表示{rhs}是一个`Vim表达式` ，而不是按键序列，见下文
    - `<silent>` 表示静默映射，不会显示Vim在处理rhs过程中对界面产生的变化。
      比如在Normal模式下定义了`nmap <c-s> :write<cr>` ，按下`<c-s>` 后可以看到界面底部显示有`write` 的字样，但如果在`<c-s>` 前面加了`<silent>` ，则不会显示

  - 

- <expr>参数

  - 在map命令里，尽管rhs可以组合出很多很强大的功能，但都是固定的序列，不能根据某个条件给出不同的序列。

  - 使用map命令的expr参数可以在rhs的位置指定一个表达式，vim会eval这个表达式，并将表达式的值作为真正的rhs序列

  - 看下面这个简单的例子：

    ```vim
    noremap  <expr>0     col('.') == 1 ? '^': '0'
    ```

    - 在Normal或者Visual模式下，按0键可以实现让光标在首列和首个非空白字符之间的切换。
    - 这里就是用了一个条件表达式，当前列是第一列时，0键被映射成`^` 键；当不在第一列时，还是0键

  - 表达式可以是一个简单的函数调用，看下面这个例子

    ```vim
    fun! Redraw()
      let l = winline()
      let cmd = l * 2 <= winheight(0) + 1 ? l <= (&so + 1) ? 'zb' : 'zt' : 'zz'
      return cmd
    endf
    
    nnoremap <expr><c-l> Redraw()
    ```

    - 这个实现的是像emacs那样智能切换光标在窗口中的位置(上/中/下)，其实就是根据光标在窗口中的当前位置，就近的选择上中下，执行对应的命令zt/zz/zb

- map-expr命令的限制

  - map-expr命令简洁、优美且灵活，可以直接把一个按键序列的功能和一个函数绑定起来。不过，这么完美的东西是不存在的，Vim在处理`map <expr>` 命令的过程中，对rhs的表达式所使用的功能有一定的限制：
    - 不能改变buffer的文本内容
    - 不能编辑另一个buffer
    - 不能使用:normal命令
    - 可以移动光标，但是之后光标会被移到原来的位置
    - 通过`:h :map-<expr>` 可以查看这些限制

  - 由于这些限制，有些时候我们在希望通过映射表达式，来完成某个改变光标位置或者改标文本内容的功能时，不得不放弃使用`<expr>` 这个命令参数。
  - 在Normal模式下，如果我们想将一个按键绑定一个函数，而且这个函数改变了光标位置或者文本内容，可以使用`:call 表达式<cr>` 的映射来绕过限制；看下面在其他模式下解决

- Insert和Command模式下的=

  - `<c-r>=` 是Vim作者留给用户在Insert和Command模式下的另一个解决方案，尽管看起来不如`<expr>` 优美，但是它没有限制，可以在表达式里调用任何移动光标和改标文本的命令和函数。

  - 举例：我想实现在Insert模式下按`<m-f>` 键实现向前移动一个单词，一般的做法是`inoremap <m-f> <c-o>e` ，但是这样会涉及到模式切换，效率比较低，当连续按`<m-f>` 时会明显感觉卡顿。所以，我的实现是直接在Insert模式里调用`norm` 命令

    ```
    fun! Exec(cmd)
        exe a:cmd
        return ''
    endf
    inoremap <expr><m-f> Exec('norm! e')
    ```

  - 这是我最初想使用`<expr>` 参数来实现这个功能，刚才提到了，Vim在处理expr的过程中，移动光标是无效的，所以有了下面的方案

    ```text
    inoremap <silent><m-f> <c-r>=Exec('norm! e')<cr>
    ```

  - Insert模式下的`<c-r>` 键，本来是用于输入某个寄存器的内容，而`=` 寄存器又是一个比较特殊的存在，它不像其他寄存器，在输入完寄存器名之后，直接返回寄存器的值，而是等待用户输入某个表达式，eval这个表达式并返回值。
    - 具体可以看插入模式下、寄存器、粘贴寄存器章节

- 键盘映射实例

  - 使用以下命令，可以在Normal Mode和Visual/Select Mode下，利用Tab键和Shift-Tab键来缩进文本：

    ```text
    nmap <tab> V>
    nmap <s-tab> V<
    vmap <tab> >gv
    vmap <s-tab> <gv
    ```

  - 使用以下命令，指定F10键来新建标签页：

    ```text
    :map <F10> <Esc>:tabnew<CR>
    ```

    - 其中：<Esc>代表Escape键；<CR>代表Enter键；而功能键则用<F10>表示。首先进入命令行模式，然后执行新建标签页的:tabnew命令，最后返回常规模式。
    - 同理：对于组合键，可以用<C-Esc>代表Ctrl-Esc；使用<S-F1>表示Shift-F1。对于Mac用户，可以使用<D>代表Command键。

  - Alt键可以使用<M-key>或<A-key>来表示。

- 关于键盘符号的详细说明，请使用:h key-notation命令查看帮助信息。

- 使用:map命令，可以列出所有键盘映射。其中第一列标明了映射在哪种模式下工作：标记模式<space>常规模式，可视化模式，运算符模式n常规模式v可视化模式o运算符模式!插入模式，命令行模式i插入模式c命令模式

- 如果想要取消一个映射，可以使用以下命令：

  ```text
  :unmap <F10>
  ```

  - 注意：必须为:unmap命令指定一个参数。如果未指定任何参数，那么系统将会报错，而不会取消所有的键盘映射。

- 针对不同模式下的键盘映射，需要使用与其相对应的unmap命令。例如：使用:iunmap命令，取消插入模式下的键盘映射；而取消常规模式下的键盘映射，则需要使用:nunmap命令。

  ![](https://pic2.zhimg.com/80/v2-6baf840cdfce6130262a917c164923dd_1440w.png)

- 可以使用以下命令，取消所有映射。请注意，这个命令将会移除所有用户定义和系统默认的键盘映射。

  ```text
  :mapclear
  ```

##### 前缀键

- Vim预置有很多快捷键，再加上各类插件的快捷键，大量快捷键出现在单层空间中难免引起冲突。为缓解该问题，而引入了前缀键<leader>。藉由前缀键， 则可以衍生出更多的快捷键命名空间（namespace)。例如将r键配置为<leader>r、<leader><leader>r等多个快捷键。
- 使用`:help <leader>`命令，可以查看关于前缀键的更多信息。

###### 定义前缀键

- 前缀键默认为“\”。使用以下命令，可以将前缀键定义为逗号：

  ```vim
  let mapleader=","
  ```

- 使用以下命令，利用转义符“\”将前缀键设置为空格键也是不错的主意：

  ```vim
  let mapleader = "\<space>"
  ```

###### 配置实例

- 定义以下快捷键，用于删除当前文件中所有的行尾多余空格：

  ```vim
  nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>
  ```

- 定义以下快捷键，用于快速编辑和重载[vimrc配置文件](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)：

  ```vim
  nnoremap <leader>ev :vsp $MYVIMRC<CR>
  nnoremap <leader>sv :source $MYVIMRC<CR>
  ```

- 定义以下快捷键，使用前缀键和数字键快速切换[缓冲区](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)：

  ```vim
  nnoremap <leader>1 :1b<CR>
  nnoremap <leader>2 :2b<CR>
  nnoremap <leader>3 :3b<CR> 
  ```

##### 缩写

- 利用:ab[breviate]缩写命令，我们可以用一个缩写来代替一组字符，此后只要输入缩写，就可以自动插入其代表的字符串以提高输入效率。

###### 设置缩写

- 使用以下命令，将定义ad来代替advertisement：

  ```text
  :abbreviate ad advertisement
  ```

  - 当想要输入advertisement时，只要输入ad，然后：
    - 如果按下Ctrl-]键，可以输入advertisement并停留在插入模式；
    - 如果按下Esc键，将插入扩展字符并返回命令模式；
    - 如果按下Space或Enter键，那么将在插入扩展字符后，自动增加空格或回车，并停留在插入模式。

###### 不同模式下的缩写

- 使用下表中不同形式的abbreviate命令，可以针对特定的模式设置缩写：
  - 所有模式:abbreviate
  - 插入模式:iabbrev
  - 命令行模式:cabbrev

###### 缩写实例

- 我们可以为多个单词设置缩写。例如以下命令，将设置Jack Berry的缩写为JB。

  ```text
  :abbreviate JB Jack Berry
  ```

- 如果你编写程序，那么利用以下设置，可以加快添加注释的速度：

  ```text
  :abbreviate #b /**********************
  :abbreviate #e **********************/
  ```

- 如果你设计网页，那么利用以下缩写可以快速增加标签。其中<CR><LF>将在标签间自动插入换行，以方便你继续输入内容。

  ```text
  :iabbrev p <p><CR><LF></p>
  ```

- 利用以下命令，我们甚至还可以定位光标所处的位置：

  ```text
  :iabbrev icode <code class="inset">!cursor!</code><Esc>:call search('!cursor!','b')
  ```

- 我们还可定义命令缩写。例如以下命令，将在新的标签页中显示帮助信息：

  ```text
  :cabbrev h tab h
  ```

- 我们可以将常用的缩写命令定义在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2012/01/vim-vimrc.html)配置文件之中，它们将在Vim启动时自动装载，而不需要再逐一重新定义。

###### 查看缩写

- 使用:abbreviate命令，将列出所有缩写定义，其中第一列显示缩写的类型：
  - 标记模式!插入模式，命令行模式i插入模式c命令模式

###### 取消缩写

- 可以使用以下命令，移除某个缩写：

  ```text
  :unabbreviate ad
  ```

- 针对不同模式下的缩写，需要使用与其相对应的unabbreviate命令。例如：使用:iunabbreviate命令，取消插入模式下的缩写，而:iabclear命令则会清除所有插入模式的缩写定义；依此类推，取消和清除命令行模式下的缩写，则需要使用:cunabbreviate和:cabclear命令。

- 如果想要清除所有缩写，可以使用以下命令：

  ```text
  :abclear
  ```

##### 标记

- 我们可以对文本进行标记，以方便在文档的不同位置间跳转。

###### 创建标记

- 将光标移到某一行，使用ma命令进行标记。其中，m是标记命令，*a*是所做标记的名称。
- 可以使用小写字母a-z或大写字母A-Z中的任意一个做为标记名称。小写字母的标记，仅用于当前缓冲区；而大写字母的标记，则可以跨越不同的缓冲区。例如，你正在编辑File1，但仍然可以使用'A命令，移动到File2中创建的标记A。

###### 跳转标记

- 创建标记后，可以使用'a命令，移动到指定标记行的首个非空字符。这里'是单引号。也可以使用`a命令，移到所做标记时的光标位置。这里是反引号（也就是数字键1左边的那一个）。

###### 列示标记

- 利用:marks命令，可以列出所有标记。这其中也包括一些系统内置的特殊标记（Special marks）：

  ![](https://pic3.zhimg.com/80/v2-3ad270e389126612cd2e5264a0930a4e_1440w.png)
  ```
  . 最近编辑的位置
  
  0-9 最近使用的文件
  
  ∧ 最近插入的位置
  
  ' 上一次跳转前的位置
  
  " 上一次退出文件时的位置
  
  [ 上一次修改的开始处
  
  ] 上一次修改的结尾处
  ```

###### 删除标记

- 如果删除了做过标记的文本行，那么所做的标记也就不存了。我们不仅可以利用标记来快速移动，而且还可以使用标记来删除文本，例如在某一行用ma做了标记，然后就可以使用d'a来删掉这一行。当然，我们也可以使用y'a命令就可以来复制这一行了。
- 使用:delmarks a b c命令，可以删除某个或多个标记；而:delmarks! 命令，则会删除所有标记。
- 利用:help mark-motions命令，可以查看关于标记的更多帮助信息。
- [vim-signature](https://link.zhihu.com/?target=https%3A//github.com/kshenoy/vim-signature)插件用于在屏幕最左侧显示标记。

##### 备份文件

- Vim利用writebackup和backup两个选项，在编辑文件的过程中，自动生成备份文件，以防止异常情况下的数据丢失。

###### 启用文件备份

- 在默认情况下，Vim已经设置了writebackup选项。我们可以使用以下命令，启用backup选项。vim将首先删除旧的备份文件，然后再为正在编辑的文件生成新的备份文件：

  ```vim
  :set backup
  ```

###### 备份文件名称

- 默认情况下，备份文件的名称是在原始文件名最后加上“~”后缀。例如，正在编辑一个名为“data.txt”的文件，那么Vim将产生名为“data.txt~”的备份文件。我们也可以使用以下命令，来自定义备份文件扩展名，新的备份文件名将命名为“data.txt.bu”。

  ```vim
  :set backupext=.bu
  ```

###### 备份文件位置

- 默认情况下，备份文件将存储于原文件相同的目录下。使用以下命令，可以设置备份文件存放到指定位置：

  ```vim
  :set backupdir=C:/Temp
  ```

- 需要注意的是，如果在不同目录下编辑相同名称的文件，在保存退出时，Vim会将备份文件放置到同一指定的目录中，名字冲突会使已存在的备份文件被覆盖。

###### 备份文件过滤

- 如果你并不需要对所有文件都进行备份，那么可以利用以下命令取消对指定目录下文件的备份：

  ```vim
  set backupskip=D:/Temp/*
  ```

- 需要注意的是，Windows文件路径中斜线（/）的用法。

###### 禁止文件备份

- 在保持默认writebackup选项的情况下，我们可以使用以下命令，取消备份文件的生成：

  ```vim
  :set nobackup
  ```

- 需要注意的是，如果同时设置了nobackup和nowritebackup选项，那么在磁盘已满而更新文件时会造成数据的丢失，所以我们最好不要改变默认的writebackup选项。

##### 交换文件

- 在编辑文件的过程中，Vim将会在当前目录中自动生成一个以*.swp*结尾的临时交换文件，用于备份缓冲区中的内容，以便在意外退出时可以恢复之前编辑的内容。

###### 启用/禁用交换文件

- 可以使用以下命令，设置生成交换文件：

  ```vim
  :set swapfile
  ```

- 可以使用以下命令，设置Vim不产生交换文件：

  ```vim
  :set noswapfile
  ```

- 注意，以上设置仅针对当前文件生效。

###### 处理交换文件

- 当完成编辑并保存退出后，临时交换文件将会被删除；但如果Vim意外退出，那么这个临时文件就会留在硬盘中。当Vim再次启动时，会检查当前目录中是否存在交换文件。如果存在，则意味着Vim正在编辑此文件，或者在上次编辑过程中意外退出，这时Vim就会给出警告信息，并要求我们在以下四个选项中做出选择：
  - **Open Read-Only**（以只读方式打开）：如果我们想要查看文件内容或是有另一个编辑过程正在运行，那么可以选择此选项；
  - **Edit anyway**（编辑文件）：请尽量不要选择此选项。因为如果同时有两个或是多个编辑过程同时编辑一个文件，那么只有最后一个保存的编辑过程有效；
  - **Recover**（恢复）：如果在编辑过程中vim意外退出，那么可以选择此选项尝试从交换文件恢复文档；
  - **Quit**（退出）：选择此选项，将取消对此文件的修改。

###### 查看交换文件

- Vim意外退出时，并不会覆盖旧的交换文件，而是会重新生成新的交换文件。例如，第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。

- 使用以下命令，可以查看当前交换文件的名称：

  ```vim
  :swapname
  ```

- 也可以在命令行中使用以下命令，列示当前目录和临时目录下的交换文件：

  ```vim
  vim -r
  ```

###### 交换文件选项

- 根据默认设置，交换文件会每隔4000毫秒（4秒）或者200个字符保存一次。我们可以使用以下命令，修改保存交换文件的频率：

  ```vim
  :set updatetime=23000
  :set updatecount=400
  ```

  - 注意，如果我们将updatecount的值为0，那么就将不保存交换文件。

- Vim默认在当前文件所处的目录下产生交换文件，我们可以通过directory选项来更改交换文件产生的目录。例如，使用以下命令将交换文件存放在/tmp目录下：

  ```vim
  :set directory=/tmp
  ```

- 注意，如果我们将交换文件存储在一个指定目录，那么当编辑不同目录下相同名称的文件时，就会产生命名冲突。我们可以将directory选项设置为一个以逗号分隔的目录列表，并将当前目录(.)设为目录列表的第一个选项，这样交换文件首先会被存放在当前目录下。

  ```vim
  :set directory=.,/tmp
  ```

###### 保存交换文件

- 使用以下命令，可以保存修改到交换文件中，而原始文件则保持不变（直到使用:write或ZZ命令退出时原始文件才会被重写）。也就是说，我们可以在丢失原始文件的情况下，使用交换文件来恢复文档。

  ```vim
  :preserve
  ```

- 可以使用以下命令，来修复指定的文件：

  ```vim
  :recover temp.txt
  ```
  - 如果存在多个交换文件，那么可以根据屏幕提示选择从指定的交换文件恢复：

- 如果没有指定文件名，那么将默认恢复当前缓冲区中的文件。如果试图修复的文件正处于编辑状态，那么将返回错误。如果想要放弃所做的编辑并修复文档，那么可以使用以下命令进行强制修复：

  ```vim
  :recover! temp.txt
  ```

- 在命令行下使用以下命令，可以从指定的交换文件进行恢复：

  ```vim
  vim -r file.txt.swo
  ```

- 你可以使用以下命令，查看关于交换文件的帮助信息：

  ```vim
  :help swap-file
  ```

##### vimrc

- 在vim启动过程中，首先将查找配置文件并执行其中的命令。初始化文件一般有vimrc、gvimrc和exrc三种。

- 使用`:version`命令，可以查看配置文件的详细列表：

  ![](https://pic3.zhimg.com/80/v2-0f2f2a10817b30f70d42e59886a1e2ba_1440w.jpg)

###### 配置文件位置

- **vimrc**是主配置文件，它有全局和用户两种版本。

- 全局global vimrc文件，存放在Vim的安装目录中。可以使用以下命令，确定Vim的安装目录：

  ```vim
  :echo $VIM
  ```

  - 默认情况下，系统vimrc存放在以下位置：

    Linux: /usr/share/vim/vimrc

    Windows: c:\program files\vim\vimrc

- 用户personal vimrc文件，存放在用户主目录中。可以使用以下命令，确定用户主目录：

  ```vim
  :echo $HOME
  ```

  - 默认情况下，用户vimrc存放在以下位置：

    Linux: /home/username/.vimrc

    Windows: c:\documents and settings\username\_vimrc

- 用户personal vimrc文件，可以使用以下命令确定：

  ```vim
  :echo $MYVIMRC
  ```

- 注意：用户配置文件优先于系统配置文件。

- 注意：在Unix和Linux下，vim的配置文件被命名为以点开头的隐藏文件；而在Windows下，配置文件则以下划线开头命名。

###### 编辑配置文件

- 可以使用以下命令，新建缓冲区来编辑配置文件：

  ```vim
  :edit $MYVIMRC
  ```

- 也可以使用以下命令，新建标签页来编辑配置文件：

  ```vim
  :tabedit $MYVIMRC
  ```

###### 应用配置文件

- 修改配置文件后，需要重新启动Vim，或使用:source命令来应用新的设置：

  ```vim
  :source $MYVIMRC
  ```

- 我们可以在配置文件中增加以下命令，在保存后自动应用配置：

  ```vim
  autocmd bufwritepost .vimrc source $MYVIMRC
  ```

###### 配置文件实例

- 为了更结构化和模块化的组织vimrc文件，通常会利用自动[折叠](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-63-Fold.html)功能来分节设置各类选项。

  - 例如以下语法将设置一个章节，并将具体的选项包含其中：

  ```vim
  " Section Name {{{
  	set number "This will be folded
  " }}}
  ```
  - 打开vimrc文件之后，将仅仅显示折叠之后的章节结构：

    ![](https://pic3.zhimg.com/80/v2-9dc922804bfbcebe6d2bdee23b3cadee_1440w.jpg)

  - 展开折叠将可以查看详细的配置命令。建议使用引号（"）进行详细注释：

    ![](https://pic2.zhimg.com/80/v2-93903045265b4daf524ba49d4d4025c5_1440w.jpg)

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help vimrc
  ```

##### 模式行

- 程序员对于制表符常常有不同的偏好，有的使用8个空格，而有的则使用4个空格。可以想见，如果使用不同设置的用户操作相同的文件，必将对文本格式造成影响。

- 如果希望针对特定文件应用特定的设置，那么修改全局性的vimrc配置文件就显得小题大做了；而使用模式行(modeline)，则可以将选项设置配置在文件本身当中。

- 例如将以下模式行放置到文件开头，将在打开该文件时设置制表符为4个空格：

  ```vim
  /* vim:set tabstop=4: */
  ```

###### 启用模式行

- 默认设置下，‘modeline’选项是打开的，Vim将会在文件的开头5行和结尾5行中查找模式行：

  ```vim
  :set modeline
  ```

- 如果希望改变扫描的行数，那么可以设置‘modelines’选项：

  ```vim
  :set modelines=1
  ```

- 定义以下快捷键，可以启用模式行并自动应用到当前文件，而不需要重新打开文件：

  ```vim
  :nnoremap <leader>ml :setlocal invmodeline <bar> doautocmd BufRead<cr>
  ```

- 模式行主要有以下两种格式：

  - 不包含set命令的格式

    - [text{white}]{vi:|vim:|ex:}[white]{options}

    - 模式行将持续到行尾处结束；

    - 选项之间不能包含空格。

    - 以下为正确的模式行：

      ```vim
      /* vim:tabstop=4:expandtabs:shiftwidth=4 */
      ```

    - 以下模式行选项中包含空格，将报错“Error E518: Unknown option: */”：

      ```vim
      /* vim: noai:ts=4:sw=4 */
      ```

  - 包含set命令的格式

    - [text{white}]{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]

    - 模式行将在第二个“:”处结束；

    - 模式行的开头和结尾可放置任意字符，建议使用“/* */”；

    - 开头字符之后的空格为必需的分隔符，不可以省略；

    - 选项之间以空格分隔。

    - 以下为正确的模式行：

      ```vim
      /* vim: set ai tw=75: */
      ```

    - 以下模式行开头字符之后缺少空格，将无法生效，但不会报错：

      ```vim
      /*vim: set tabstop=4: */
      ```

###### 模式行实例

- 在Vim帮助文件的末尾，将发现以下模式行：

  ```vim
  vim:tw=78:ts=8:noet:ft=help:norl:
  ```
  - 其中，tw(textwidth)选项设置最大文本宽度为78；ts(tabstop)选项设置制表符为8个空格；noet(noexpandtab)选项设置为不扩展制表符；ft(filetype)选项设置文件类型为help；norl(norightleft)选项设置文本从左向右显示。

###### 禁用模式行

- 使用以下设置，Vim将不会查找模式行：

  ```vim
  :set nomodeline
  ```

###### 帮助信息

- 使用以下命令，可以查看当前设置：

  ```vim
  :verbose set modeline? modelines?
  ```

- 使用以下命令，可以查看帮助信息：

  ```vim
  :help 'modeline'
  :help 'modelines' 
  ```

##### viminfo

- Vm使用viminfo选项，来定义如何保存会话（session）信息，也就是保存Vim的操作记录和状态信息，以用于重启Vim后能恢复之前的操作状态。

- viminfo文件默认存储在以下位置：

  - Linux和Mac：$HOME/.viminfo，例如：~/.viminfo
  - Windows：$HOME\_viminfo，例如：C:\Users\yiqyuan\_viminfo

- viminfo文件主要保存以下内容：

  - Command Line History（命令行历史纪录）
  - Search String History（搜索历史纪录）
  - Expression History（表达式历史纪录）
  - Input Line History（输入历史记录）
  - Debug Line History（调试历史纪录）
  - Registers（寄存器）
  - File marks（标记）
  - Jumplist（跳转）
  - History of marks within files（文件内标记）

- Vim在退出时，会将上述信息存放到viminfo文件中；在启动时，将会自动读取viminfo信息文件。

- 使用以下命令，可以手动创建一个viminfo文件：

  ```vim
  :wviminfo file_name
  ```

- 使用以下命令，可以重新读去viminfo文件：

  ```vim
  :rviminfo
  ```

- 使用以下命令，可以查看关于viminfo文件的帮助信息：

  ```vim
  :help viminfo
  ```

###### viminfo选项

- viminfo选项可以指定保存哪些内容，以及在何处的viminfo文件中保存这些信息。viminfo选项是一组使用逗号分隔的字符串；其中每个参数，是以单个字符开头的数值或字符串值。

- Windows下的默认值为：

  ```vim
  set viminfo='100,<50,s10,h,rA:,rB:
  ```

- Linux和Mac下的默认值为：

  ```vim
  set viminfo='100,<50,s10,h
  ```

<img src="https://pic3.zhimg.com/80/v2-8a207f9f9d39dadd8388b75dc3c3255e_1440w.jpg" style="zoom:51%;" />

- 在单独指定viminfo文件的位置时，为了不覆盖viminfo选项的当前值，通常会在设置命令中使用“+=”操作符：

  ```vim
  :set viminfo+=n$LOCALAPPDATA/_viminfo
  :set viminfo+=nC:\\_viminfo
  ```

- 您可以参考以下命令，在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件中，定义viminfo选项：

  ```vim
  set viminfo=\"50,'1000,h,f1,rA:,r$TEMP:,r$TMP:,r$TMPDIR:,:500,!,n$VIM/_viminfo
  ```
  <img src="https://pic4.zhimg.com/80/v2-5a979ee7e81157bb0f8d710b6faa47bb_1440w.jpg" style="zoom:50%;" />
  - 请不要将“<”设置过大，因为此选项将影响保存至viminfo文件中的信息量。在Vim启动时，如果读取尺寸过大的viminfo文件，将影响Vim启动速度；
  - 请在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)文件开头，首先定义`:set nocompatible`选项。

- 使用以下命令，可以查看viminfo选项的更多信息：

  ```vim
  :help 'viminfo' 
  ```

##### 会话

- 会话信息，将保存所有编辑窗口和全局设置。通过恢复会话，可以快速切换回之前工作环境。可以认为，会话是[viminfo](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-01-viminfo.html)的扩展补充，viminfo文件中保存了会话所需要使用的具体设置信息。

- 如下图所示，我在编辑本文档的同时，打开了帮助文件和命令终端。首先，将当前编辑状态保存到会话文件；稍后，只需要恢复会话，就可以继续使用之前的窗口布局进行编辑了，而省去了手动打开多个窗口的繁琐。

  <img src="https://pic3.zhimg.com/80/v2-04599d1db4e4250649d20b73f8e35652_1440w.jpg" style="zoom:51%;" />

###### 保存会话

- 使用以下命令，将保存会话信息至当前目录下，以“Session.vim”命名的文件：

  ```vim
  :mksession
  ```

- 如果已经存在同名的会话文件，那么需要在命令中使用“!”参数，进行强制覆盖：

  ```vim
  :mks!
  ```

- 也可以在命令中，指定会话信息文件的位置：

  ```vim
  :mksession ~/mysession.vim 
  ```

###### 恢复会话

- 在[启动](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-209-Start.html)Vim时，通过指定“-S”参数，可以恢复之前保存的编辑会话：

  ```vim
  $ vim -S Session.vim
  ```

- 在Vim中使用以下命令，也可以恢复会话信息：

  ```vim
  :source Session.vim
  ```

- 使用以下命令，可以查看关于会话信息的帮助文件：

  ```vim
  :help session
  ```

###### 会话选项

- 会话选项sessionoptions，用于指定保存会话的内容，默认值如下：

  ```vim
  :set sessionoptions = blank,buffers,curdir,folds,help,options,tabpages,winsize,terminal
  ```

  - sessionoptions选项是一组使用逗号分隔的字符串，包含以下参数：
    - *blank*
      恢复编辑无名缓冲区的[窗口](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-14-MultiWindows.html)；
    - *buffers*
      恢复所有[缓冲区](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-13-MultiBuffers.html)（包括隐藏和未载入的缓冲区）；
    - *curdir*
      恢复当前目录；
    - *folds*
      恢复[折叠](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-63-Fold.html)；
    - *globals*
      恢复以大写字母开始并至少包含一个小写字母的全局变量；
    - *help*
      恢复帮助窗口；
    - *localoptions*
      恢复（限定于缓冲区内）本地选项；
    - *options*
      恢复全局映射和选项；
    - *resize*
      恢复以行列指定的窗口大小；
    - *sesdir*
      设置当前目录为会话文件所在的位置；
    - *salsh*
      在文件名中使用salsh（/），来代替backslah（\）；
    - *tabpages*
      恢复所有[标签页](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-15-Tabs.html)；
    - *terminal*
      恢复终端窗口；
    - *unix*
      使用Unix模式的行尾标志（<NL>）；
    - *winpos*
      恢复 GUI Vim 的窗口位置；
    - *winsize*
      恢复窗口尺寸（相对于屏幕大小）；

- 使用以下命令，可以查看关于会话选项的帮助信息：

  ```vim
  :help 'sessionoptions' 
  ```

##### 命令历史记录

- Vim会将命令历史记录，保存在[viminfo](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-01-viminfo.html)文件中；通过viminfo和history选项，可以控制存储历史记录的类型和数量；在[命令行模式](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-46-CommandlineMode.html)和[搜索文本](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2009/03/vim.html)时，则可以重新调用这些历史记录。

- 命令历史可以分为以下几种类型（{name}）：

  <img src="https://pic3.zhimg.com/80/v2-dca2ca1237d08b4d820428418b1e3a82_1440w.jpg" style="zoom:50%;" />

- 使用以下命令，可以显示命令行历史记录：

  ```vim
  :history
  ```

- 使用以下命令，可以显示所有类型的历史记录：

  ```vim
  :history all
  ```

- 使用以下格式的:history命令，可以查看指定类型和指定数目的历史记录：

  ```vim
  :his[tory] [{name}] [{first}][, [{last}]]
  ```

  - `{name}`，指定历史记录[类型](file:///E:/Anthony_GitHub/learn-vim/learn-vi-46-01-History.html#history_name)；

  - `{first}`，指定命令历史的起始位置（默认为第一条记录）；

  - `{last}`，指定命令历史的终止位置（默认为最后一条记录）。

  - 如果没有指定 {first} 和 {last}，那么将会列出所有命令历史。

  - 如果指定了 {first} 和 {last}，那么就会列出指定范围内的历史记录条目。例如以下命令，将列出第一到第五条命令行历史：

    ```vim
    :history c 1,5
    ```

- 正数，表示历史记录的绝对索引，也就是:history命令列出的第一列数字。即使历史记录中的其它条目被删除了，该索引数字也会保持不变。例如以下命令，将列出指定位置（第五条）命令行历史：

  ```vim
  :history c 5
  ```

- 负数，表示历史记录的相对索引。以最新一条记录 (索引号为 -1) 为基准向后算起。如以下命令，将列出所有历史记录中倒数第二条记录：

  ```vim
  :history all -2
  ```

- 使用以下命令，则会列出所有历史记录中最近的两条记录：

  ```vim
  :history all -2,
  ```

- 使用以下命令，可以查看:history命令的帮助信息：

  ```vim
  :help :history
  ```

###### 删除历史记录

- 使用以下命令，可以删除命令行历史记录：

  ```vim
  :call histdel("")
  ```

- 可以删除指定类型的历史记录。例如使用以下命令，将删除所有查询历史记录：

  ```vim
  :call histdel("seach")
  ```

- 您也可以直接编辑[viminfo](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-01-viminfo.html)文件，直接删除其中的历史记录。请注意，需要重启Vim，以重新读取修改后的viminfo文件。

###### 命令历史选项

- 通过history选项，可以控制记录历史记录的数量（默认为50）。例如以下命令，设置保存1000条命令历史记录：

  ```vim
  :set history=1000
  ```
  - 请注意：在[viminfo](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-01-viminfo.html)选项中，也有命令历史相关参数；请在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件中，检查'viminfo'和'history'设置的的一致性和优先级。

##### 信息

- Vim将默认记录近200次的信息显示。

###### 查看信息

- 使用以下命令，可以查看上一个命令的输出信息：

  ```vim
  g< 
  ```

- 使用以下命令，在显示信息的同时，也会将其存储在信息历史（message-history）之中：

  ```vim
  :echom "Hello World"
  ```

- 使用以下命令，可以查看所有信息：

  ```vim
  :messages
  ```

- 而使用以下命令，则可以查看最近一条报错信息（error-messages）：

  ```vim
  :echo errmsg
  ```

- 从[7.4.1735](https://link.zhihu.com/?target=https%3A//github.com/vim/vim/releases/tag/v7.4.1735)版本开始，可以使用以下命令清除信息历史：

  ```vim
  :messages clear
  ```

###### 信息语言

- 使用以下命令，可以查看显示信息的语言：

  ```vim
  :language message
  ```

- 通过以下变量，也可以查看显示信息的语言：

  ```vim
  :echo LC_MESSAGES
  ```

- 在vimrc文件中使用以下命令，可以指定信息使用中文显示：

  ```vim
  :language message zh_CN.UTF-8
  ```

- 建议使用英文显示信息，以便在互联网上进行查找相关资源：

  ```vim
  :language message en_US.UTF-8
  ```

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help :messages
  ```

###### shortmess选项

- 'shortmess'选项，用于控制信息显示的种类和详细程度。其默认值为：

  ```vim
  :set shormess=filnxtToOS
  ```
  - 以下为主要标志位的含义（灰色行为默认值中的标志位）：

    <img src="https://pic2.zhimg.com/80/v2-748c51fee4a5364b9c16f22c53d40d89_1440w.jpg" style="zoom:80%;" />

- 如果不希望使用信息缩写，那么可以使用以下命令：

  ```vim
  :set shm=
  ```

- 如果希望使用缩写，但不截短信息，那么可以使用以下命令：

  ```vim
  :set shm=a
  ```

- 如果希望使用缩写，并在必要时截短信息，那么可以使用以下命令：

  ```vim
  :set shm=at
  ```

- 从[8.1.1270](https://link.zhihu.com/?target=https%3A//github.com/vim/vim/releases/tag/v8.1.1270)版本开始，在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件中增加以下设置，可以在屏幕底部，显示匹配搜索结果的总数，以及当前所处第几个匹配结果：

  ```vim
  set shortmess-=S
  ```

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help 'shortmess'
  ```

##### 重定向

###### 重定向到文件

- 使用以下命令，在将信息输出到屏幕的同时，也会保存到指定的文件中：

  ```vim
  :redir > {file}
  ```

- 如果指定的文件以及存在，那么需要使用!参数进行强制覆盖：

  ```vim
  :redir! > {file}
  ```

- 如果希望信息被追加到文件末尾，那么可以使用以下命令：

  ```vim
  :redir >> {file}
  ```

- 假设需要查询大量的信息输出（例如:version命令），或者保存调试信息，那么信息重定向就会非常有价值。

- 使用以下命令，可以停止信息的重定向：

  ```vim
  :redir END
  ```

###### 重定向到寄存器

- 我们可以将信息输出重定至[寄存器](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-12-Register.html)之中，比如剪贴板寄存器（+）、命名寄存器（a-z,A-Z）和未命名寄存器（"）。

- 使用以下命令，可以将信息输出重定向至剪贴板寄存器：

  ```vim
  :redir @+
  ```

- 这样您就可以使用`"+p`命令， 将信息输出粘贴到当前文本。

- 使用以下命令，可以将命令历史记录粘贴到当前文件中：

  ```vim
  :redir @+
  :set nomore
  :history
  :put +
  :set more
  :redir END
  ```
  - 其中，`:set nomore`命令用于暂定显示“--More--”信息，否则在分页显示命令历史记录时，需要点击按键以继续下一页的显示。

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help :redir
  ```

##### wildmenu

- 使用'wildmenu'选项，将启用增强模式的命令行补全。在命令行中输入命令时，按下'wildchar'键（默认为Tab）将自动补全命令和参数：此时将在命令行的上方显示可能的匹配项；继续按下'wildchar'键，可以遍历所有的匹配项；也可以使用方向键或者CTRL-P/CTRL-N键，在匹配列表中进行移动；最后点击回车键，选择需要的匹配项。

- 使用以下命令，可以启用wildmenu：

  ```vim
  :set wildmenu
  ```

  - 例如在命令行中输入“:spe”，然后点击Tab键，将列出以spe开头的命令列表；再次点击Tab键，将可以在wildmenu中遍历匹配的命令：

- 使用以下命令，可以查看wildmenu的帮助信息：

  ```vim
  :help wildmenu
  ```

###### wildmode

- 在命令行中输入命令时，文件名也是可以自动补全的。例如希望编辑当前目录下的某个文件，在输入:e命令和空格之后，点击Tab键，将自动补全文件名。而补全的方式，则是通过以下'wildmode'选项来控制：

- 使用""选项，将仅仅使用第一个匹配结果；即使再次按下wildchar键，也不会继续查找其它匹配项：

  ```vim
  :set wildmode=
  ```

- 使用"full"选项，将在wildmenu中显示匹配的文件；点击wildchar键，可以遍历匹配的文件：

  ```vim
  :set wildmode=full
  ```

- 使用"longest"选项，将用最长的公共子串补全：

  ```vim
  :set wildmode=longest
  ```

- 使用"longest:full"选项，将用最长的公共子串补全，并显示在wildmenu中：

  ```vim
  :set wildmode=longest:full
  ```

- 使用"list"选项，将显示可能匹配的文件列表：

  ```vim
  :set wildmode=list
  ```

- 使用"list:full"选项，将显示可能匹配的文件列表，并使用第一个匹配项进行补全：

  ```vim
  :set wildmode=list:full
  ```

- 使用"list:longest"选项，将显示可能匹配的文件列表，并使用最长的子串进行补全：

  ```vim
  :set wildmode=list:longest
  ```

- 推荐使用"**list:longest,full**"选项，点击Tab键，将显示可能匹配的文件列表，并使用最长的子串进行补全；再次点击Tab键，可以在wildmenu中遍历匹配的文件列表：

  ```vim
  set wildmode=list:longest,full
  ```

- 使用以下命令，可以查看wildmode的帮助信息：

  ```vim
  :help wildmode
  ```

###### wildignore

- 通过'wildignore'选项，可以在匹配列表中忽略指定类型的文件：

  ```vim
  :set wildignore=*.dll,*.exe,*.jpg,*.gif,*.png
  ```

- 在'suffixes'选项中，会列出一系列文件名的前缀。当有多个文件符合匹配条件时，包含指定前缀的文件则会获得较低的优先级。也即是说，这些文件将会显示在匹配列表的最后。以下为suffixes选项的默认值：

  ```vim
  :set suffixes=.bak,~,.o,.h,.info,.swp,.obj
  ```

###### wildchar

- 通过'wildchar'选项，可以设置命令行自动补全的触发键。默认为Tab键。例如以下命令，将其设置为F12键：

  ```vim
  :set wildchar=<F12>
  ```

###### wildmenu应用

- 在命令行中输入`:color`以及空格，然后点击Tab键，将列出所有可用的[配色方案(Color Scheme)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-62-ColorScheme.html)，继续点击Tab键可以选用需要的配色方案。

  ```vim
  :color 
  ```

- 使用以下命令，可以查看所有外部（例如PATH）和内部（例如MYVIMRC）变量：

  ```vim
  :echo $
  ```

##### 命令相关选项

###### 路径分隔符选项

- 在Windows下，文件路径中使用反斜杠（Backslash）：

- 在Linux和Mac下，文件路径中使用正斜杠（Forward slash）：

- 'shellslash'选项，仅适用于Windows操作系统，并且默认是关闭的。为了保证与Unix风格的兼容性，建议在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件中，使用以下命令启用此选项：

  ```vim
  :set shellslash
  ```

  - 使用'shellslash'选项，可以在扩展文件名时使用正斜杠。即使你在输入文件名时使用反斜杠，Vim也会自动将其转换为正斜杠。

###### 报错响铃选项

- 当Vim捕获一个错误时，将会显示错误信息。如果希望同时发出报错响铃 (鸣叫或屏幕闪烁)，那么可以启用'errorbells'选项：

  ```vim
  :set errorbells
  ```

- 使用以下命令，则可以关闭'errorbells'选项：

  ```vim
  :set noerrorbells
  ```

- 'visualbell'选项，用于设置响铃的行为：鸣叫、屏幕闪烁或什么都不做。默认情况下，'visualbell'选项是关闭的。通过以下命令启用visualbell选项，将使用可视响铃代替鸣叫。当输入错误时，屏幕就会闪动然后回到正常状态：

  ```vim
  :set visualbell
  ```

- 通过以下命令，则可以关闭visualbell选项（而使用鸣叫）：

  ```vim
  :set novisualbell
  ```

- 如果既不想要鸣叫也不想要屏幕闪烁，那么可以使用以下设置：

  ```vim
  :set vb t_vb=
  ```

###### 信息显示选项

- 启用'showmode'选项，将在屏幕底部显示当前所处的模式：

  ```vim
  :set showmode
  ```

- 启用'showcmd'选项，将会在输入命令时，在屏幕底部显示出部分命令：

  ```vim
  :set showcmd
  ```

- 例如希望输入fx命令来查找字符“x”时，当我们输入f时就会在底部显示“f”，这在输入复杂命令时将很有帮助。

- 在[可视化模式](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-45-VisualMode.html)下，将显示选择区域的大小：

  - 在行内选择若干字符时，显示字符数；
  - 选择多于一行时，显示行数；
  - 选择可视化列块时，显示行乘以列数（比如“2x10”）。

- 默认情况下，如果屏幕底部显示的消息长度超出一行时，将会显示类似于“按回车继续”的提示信息。通过设置'cmdheight'选项来增加消息的行数，可以显示更多的信息以避免不必要的提示。例如使用以下命令，设置命令行高度为3行：

  ```vim
  :set cmdheight=3
  ```

- 默认情况下，'more'选项是启用的。当命令的输出超出一屏时（例如:version命令的输出），就会显示“-- More --”提示信息，并等待用户响应以继续显示屏更多信息：

  - 使用以下命令关闭more选项，将会持续翻滚屏幕以显示信息，而不会暂停并显示提示信息：

    ```vim
    :set nomore
    ```

- 当删除或修改多行文本时，如果被影响的行数超出了'report'选项所指定的行数（默认值为2行），那么Vim将会在屏幕底部显示所改变的行数。如果希望始终显示反馈信息，那么可以将report选项设置为0：

  ```vim
  :set report=0
  ```

  - 此时即使只是删除了一行文本，Vim也将显示反馈信息：

  ```text
  1 line less
  ```
  - 相反地，如果不希望显示变更信息，那么可以将report选项设置为较大的值。

##### 自动命令

- 自动命令，是在指定事件发生时自动执行的命令。利用自动命令可以将重复的手工操作自动化，以提高编辑效率并减少人为操作的差错。

- 比如自定义以下函数，用于在文件中插入当前日期：

  ```vim
  :function DateInsert()
  :    $read !date
  :endfunction
  ```
  - 使用以下命令，可以手动调用此函数：

    ```vim
    :call DateInsert()
    ```

  - 而通过以下自动命令，则可以在保存文件时自动执行函数，而不再需要额外的手动操作：

    ```vim
    :autocmd FileWritePre * :callDateInsert()<CR>
    ```

###### 定义自动命令

- 可以使用以下格式的autocmd命令，来定义自动命令：

  ```vim
  :autocmd [group] events pattern [nested] command
  ```

  - *group*，组名是可选项，用于分组管理多条自动命令；
  - *events*，事件参数，用于指明触发命令的一个或多个事件；
  - *pattern*，限定针对符合匹配模式的文件执行命令；
  - *nested*，嵌套标记是可选项，用于允许嵌套自动命令；
  - *command*，指明需要执行的命令、函数或脚本。

- events参数，Vim内置了近80个事件，以下表格按照类别列示了较为常用的事件：

  <img src="https://pic4.zhimg.com/80/v2-212dbfc1f437e9dfa7d2981c5522f827_1440w.jpg" style="zoom:80%;" />
  - 假设我们打开文件并输入文本，然后保存并退出，那么这些操作将以下顺序触发一系列事件：

    <img src="https://pic2.zhimg.com/80/v2-a384d50505dc47a648844f87a6b3bb3d_1440w.jpg" style="zoom:80%;" />

  - 您可以使用以下命令，获得各个事件的详细说明：

    ```vim
    :help autocommand-events
    ```

- pattern参数

  - 匹配模式用来指定应用自动命令的文件。在匹配模式中，可以使用以下特殊字符：

    ```
    * 匹配任意长度的任意字符
    ? 匹配单个字符
    \?匹配字符'?'
    . 匹配字符'.'
    , 用于分割多个pattern
    \,匹配字符','
    ```

  - 可以使用逗号来分割多个模式，以匹配多种类型的文件。例如以下命令，将对于.c和.h文件设置'textwidth'选项：

    ```vim
    :autocmd BufRead,BufNewFile *.c,*.h set tw=0
    ```

  - 您可以使用以下命令，获得匹配模式的详细说明：

    ```vim
    :help autocmd-patterns
    ```

- nested参数

  - 默认情况下，自动命令并不会嵌套执行。例如在自动命令中执行:e或:w命令，将不会再次触发BufRead和BufWrite事件。而使用nested参数，则可以激活嵌套的事件。

    ```vim
    :autocmd FileChangedShell *.c nested e!
    ```

###### 查看自动命令

- 使用以下命令，可以列出所有自动命令：

  ```vim
  :autocmd
  ```

- 你会发现自动命令的列表将会非常的长，其中既包括了在vimrc文件中用户定义的自动命令，也包括了各种插件定义的自动命令。

- 如果在命令中指定了group，那么将会列出所有与指定group相匹配的自动命令；同理，也可以在命令中指定event和pattern，以查看相匹配的自动命令：

  ```vim
  :autocmd filetypedetect * *.htm
  ```

###### 删除自动命令

- 使用以下命令，可以删除所有自动命令：

  ```vim
  :autocmd!
  ```

  - 注意：此操作也将删除插件所定义的自动命令，请谨慎操作。

- 使用以下命令，可以删除指定组的自动命令：

  ```vim
  :autocmd! group
  ```

- 在命令中指定组、事件和匹配模式，可以删除特定的自动命令：

  ```vim
  autocmd! Unfocussed FocusLost *.txt
  ```

- 在命令中使用特殊字符“*”来指代所有事件或文件。例如以下命令，将删除Unfocussed组中所有针对txt文件的自动命令：

  ```vim
  autocmd! Unfocussed * *.txt
  ```

- 在命令中忽略文件匹配模式，那么所有针对指定事件的针对命令都将被删除。例如以下命令，将删除Unfocussed组在所有针对FocusLost事件的自动命令：

  ```vim
  autocmd! Unfocussed FocusLost
  ```

###### 自动命令组

- 通过`:augroup`命令，可以将多个相关联的自动命令分组管理，以便于按组来查看或删除自动命令。例如以下命令，将C语言开发的相关自动命令，组织在“cprogram”组内：

  ```vim
  :augroup cprograms
  :    autocmd!
  :    autocmd FileReadPost *.c :set cindent
  :    autocmd FileReadPost *.cpp :set cindent
  :augroup END
  ```

- 如果我们针对同样的文件和同样的事件定义了多条自动命令，那么当满足触发条件时将分别执行多条自动命令。因此，建议在自动命令组的开头增加:autocmd!命令，以确保没有重复的自动命令存在。

- 您可以使用以下命令，获得自动命令组的帮助信息：

  ```vim
  :help :augroup
  ```

###### 自动命令选项

- 通过eventignore选项，可以忽略指定的事件，而不触发自动命令。例如使用以下命令，将忽略进入窗口和离开窗口的事件：

  ```vim
  :set eventignore=WinEnter,WinLeave
  ```

- 如果希望忽略所有事件，那么可以使用以下设置：

  ```vim
  :set eventignore=all
  ```

##### 自动命令实例

- 以下自动命令，将在离开Vim编辑器时，自动保存文件：

  ```vim
  autocmd FocusLost * :wa
  ```

###### 根据文件类型执行自动命令

- 可以根据文件类型，执行特定命令。例如以下自动命令，将删除php文件行尾的空格：

  ```vim
  autocmd BufEnter *.php :%s/[ \t\r]\+$//e
  ```

- 可以根据文件类型，载入相关插件：

  ```vim
  autocmd Filetype html,xml,xsl source $VIM/vimfile/plugin/closetag.vim
  ```

- 可以根据文件类型，设置[键盘映射](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-51-KeyMapping.html)：

  ```vim
  autocmd bufenter *.tex map <F1> :!latex %<CR>
  ```

- 可以根据文件类型，设置不同的选项：

  ```vim
  autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
  ```

###### 自动创建目录

- 定义以下自动命令，将在保存文件时，检查所指定的目录是否存在：

  ```vim
  augroup vimrc-auto-mkdir
    autocmd!
    autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
    function! s:auto_mkdir(dir, force)
      if !isdirectory(a:dir)
            \   && (a:force
            \       || input("'" . a:dir . "' does not exist. Create? [y/N]") =~? '^y\%[es]$')
        call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
      endif
    endfunction
  augroup END
  ```
  - 如果使用`:w`命令保存文件时，引用了不存在的目录，那么将显示以下询问信息：

    ```
    'XXXXX' does not exist. Create? [y/N]
    ```

  - 你可以输入“y”，以自动创建目录并保存文件。

  - 如果使用`:w!`命令保存文件时，引用了不存在的目录，那么将不会显示询问信息，而直接创建目录并保存文件。

###### 自动应用配置文件

- 在保存[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-59-vimrc.html)配置文件时，将自动重载并生效变更之后设置，而免去了关闭并重新打开Vim的手工操作：

  ```vim
  augroup Reload_Vimrc        " Group name.  Always use a unique name!
      autocmd!                " Clear any preexisting autocommands from this group
      autocmd! BufWritePost $MYVIMRC source % | echom "Reloaded " . $MYVIMRC | redraw
      autocmd! BufWritePost $MYGVIMRC if has('gui_running') | so % | echom "Reloaded " . $MYGVIMRC | endif | redraw
  augroup END
  ```

###### 自动更新时间戳

- 利用以下自动命令，将在保存文件时，自动更新文件中的时间戳信息。首先将查找以“This file last updated:”开头的行，然后将“:”之后的时间替换为当前时间。

  ```
  This file last updated: 12/23/2019 4:05:10 PM
  function! UpdateTimestamp ()
    '[,']s/^This file last updated: \zs.*/\= strftime("%c") /
  endfunction
  
  augroup TimeStamping
    autocmd!
    autocmd BufWritePre,FileWritePre,FileAppendPre * :call UpdateTimestamp()
  augroup END
  ```

### 代码开发

##### 非可见字符

- 默认情况下，Vim是不会显示space,tabs,newlines,trailing space,wrapped lines等不可见字符的。我们可以使用以下命令打开*list*选项，来显示非可见字符：

  ```text
  :set list
  ```

- 我们也可以使用以下命令，重新隐藏不可见字符：

  ```text
  :set nolist
  ```

- 通常我们会利用以下命令，切换显示或隐藏不可见字符：

  ```vim
  :set list!
  ```

###### 显示符号

- 使用:set listchars命令，可以配置使用何种符号来显示不可见字符。例如以下命令，将制表符（tab）显示为…；将尾部空格（trail）显示为·；将左则超出屏幕范围部分（precedes）标识为«；将右侧超出屏幕范围部分（extends）标识为»。

  ![](https://pic4.zhimg.com/80/v2-9a3b1d293f0d064a46680d9590203c9f_1440w.png)

- 可以使用以下命令，查看可以输入的特殊字符：

  ```text
  :digraphs
  ```

![](https://pic3.zhimg.com/80/v2-e12c63ab2209f8a88180aa15705ef086_1440w.png)

##### 折叠

- 当我们查看很长的文本时（比如程序代码），可以使用 **:set foldenable** 命令来启动折叠。首先将内容按照其结构折叠起来，查看文件的大纲，然后再针对特定的部分展开折叠，显示文本的详细内容。

- Vim将折叠等同于行来对待——你可以使用j或k命令，移动跳过包含多行的整个折叠；也可以使用y或d命令，复制或删除某个折叠。

- 通常在折叠处向左或向右移动光标，或者进入插入模式，都将会自动打开折叠。我们也可以使用以下命令定义快捷键，使用空格键关闭当前打开的折叠，或者打开当前关闭的折叠。

  ```
  :nnoremap <space> za
  ```

- 按照折叠所依据的规则，可以分为Manual（手工折叠）、Indent（缩进折叠）、Marker（标记折叠）和Syntax（语法折叠）等几种。

###### manual fold

- 使用以下命令，启用手工折叠。

  ```text
  :set foldmethod=manual
  ```

- 在可视化模式下，使用以下命令，将折叠选中的文本：手工折叠要先在可视模式下选中然后折叠

  ```text
  zf
  ```

- 通过组合使用移动命令，可以折叠指定的行。例如：使用zf70j命令，将折叠光标之后的70行；使用**5zF**命令，将当前行及随后4行折叠起来；使用zf7G命令，将当前行至全文第7行折叠起来。

- 我们也可以使用以下命令，折叠括号（比如()、[]、{}、><等）包围的区域：

  ```text
  zfa(
  ```

- Vim并不会自动记忆手工折叠。但你可以使用以下命令，来保存当前的折叠状态：

  ```text
  :mkview
  ```

- 在下次打开文档时，使用以下命令，来载入记忆的折叠信息：

  ```text
  :loadview
  ```

- 可以使用以下命令，查看关于手工折叠的帮助信息：

  ```text
  :help fold-manual
  ```

###### indent fold

- 使用以下命令，启用缩进折叠。所有文本将按照（选项*shiftwidth* 定义的）缩进层次自动折叠。

  ```text
  :set foldmethod=indent
  ```

- 使用zm命令，可以手动折叠缩进；而利用zr命令，则可以打开折叠的缩进。

- 使用以下命令，将可以根据指定的级别折叠缩进：

  ```text
  :set foldlevel=1
  ```

- 在缩进折叠的情况下，可以设置foldignore来缩进

  - 仅在 'foldmethod' 为 "indent" 时使用。 以 'foldignore' 中的字符开头的行将从周围的行中获取其折叠级别。 在检查此字符之前会跳过空格。默认的“#”适用于 C 程序。
  
- 可以使用以下命令，查看关于缩进折叠的帮助信息：

  ```text
  :help fold-indent
  ```

###### syntax fold

- 使用以下命令，启用语法折叠。所有文本将按照语法结构自动折叠。

  ```text
  :set foldmethod=syntax
  ```

- 可以使用以下命令，查看关于语法折叠的帮助信息：

  ```text
  :help fold-syntax
  ```

###### marker fold

- 使用以下命令，启用标记折叠。所有文本将按照特定标记（默认为{{{和}}}）自动折叠。

  ```text
  :set foldmethod=marker
  ```

- 我们可以利用标记折叠，在文本中同时体现结构和内容，并且能够快速跳转到文件的不同部分。

- 可以使用以下命令，查看关于标记折叠的帮助信息：

  ```text
  :help fold-marker
  ```

###### 折叠选项

- 使用:set foldcolumn=N命令，将在屏幕左侧显示一个折叠标识列，分别用“-”和“+”而表示打开和关闭的折叠。其中，*N*是一个0-12的整数，用于指定显示的宽度。

  ![](https://pic1.zhimg.com/80/v2-4f5b3a585fd7d4cac4f2595b17ec3d60_1440w.png)

- 使用以下命令，可以查看关于折叠的帮助信息：

  ```text
  :help folding
  ```

![](https://pic4.zhimg.com/80/v2-c56f304dbf1566820b5f65e158560117_1440w.png)

###### 折叠后续

- vimrc主要设置选项

  ```
  set foldenable
  set foldlevel=99
  ```

- foldenable默认是开启的，是用来控制折叠是否生效的，如果关闭之后折叠就不生效了，如果开启，打开文件会自动折叠foldlevel以上的代码片段，如果foldlevel是0代表折叠所有的代码片段，zi用来控制foldenable是否生效。如果开启的话，在文件中按zi表示全部关闭。意思是关闭这个功能。

- zm是关闭所有折叠，但是如果foldlevel是0的话，这个操作是无效的，可以用zM来关闭所有折叠。

- zr和zR类似，zR是打开所以的以及嵌套的折叠，zr是打开一级折叠，并不会打开嵌套的折叠。

- foldlevel代表折叠的层数，因为代码片段里面包含代码片段，相当于折叠里面包含折叠，这个就是折叠的层数。在开启了foldenable时自动折叠，如果foldlevel设置为99，表示自动折叠嵌套99层以上的代码，一般都没有99层，所以不可能。意思不折叠了。

- 剩下的一些命令就是打开当前的折叠和关闭当前的折叠了，和打开所有关闭所有一起使用就可以了。打开关闭当前的折叠是当前层次的折叠，如果当前层次里面还有一些嵌套，里面的嵌套是不会被额外的折叠的，相当于当前层次被折叠成一个大的折叠。如果折叠所有是每一个嵌套都会被折叠成一层，外面的在折叠一层，这样每一层都会被折叠。打开的时候需要一层一层的打开，如果折叠当前层的话打开折叠就是所有的都打开了，里面的嵌套是不用额外的打开的

##### 缩进

###### 手动缩进

- 在Normal Mode下，命令>>将对当前行增加缩进，而命令<<则将对当前行减少缩进。我们可以在命令前使用数字，来指定命令作用的范围。例如以下命令，将减少5行的缩进：

  ```text
  5<<
  ```

- 如果代码没有正确排版，那么我们可以使用==命令来缩进当前行；也可以进入可视化模式并选择多行，然后使用=命令缩进选中的行。

- 通过与[文本对象](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2016/12/vim-text-objects.html)组合，使用以下命令可以缩进{}括号内的代码。

  ```text
  =a{
  ```

- 如果需要缩进整个文件内的代码，则可以使用以下命令：

  ```text
  gg=G
  ```

- 在Insert/Replace Mode下，Ctrl-Shift-t可以增加当前行的缩进，而Ctrl-Shift-d则可以减少当前行的缩进。使用0-Ctrl-Shift-d命令，将移除所有缩进。需要注意的是，当我们输入命令中的“0”时，Vim会认为我们要在文本中插入一个0，并在屏幕上显示输入的“0”；然后当我们执行命令0-Ctrl-Shift-d时，Vim就会意识到我们要做的是减少缩进，这时0会就会从屏幕上消失。

- 缩进宽度默认为8个空格。我们可以使用以下命令，来修改缩进宽度：

  ```text
  :set shiftwidth=4
  ```

- 通过以下设置，每次点击Tab键，将增加宽度为8列的Tab缩进。

  ```text
  :set tabstop=8
  :set softtabstop=8
  :set shiftwidth=8
  :set noexpandtab
  ```

- 使用以下设置，每次点击Tab键，增加的缩进将被转化为4个空格。

  ```text
  :set tabstop=4
  :set softtabstop=4
  :set shiftwidth=4
  :set expandtab
  ```

- 其中，expandtab选项，用来控制是否将Tab转换为空格。但是这个选项并不会改变已经存在的文本，如果需要应用此设置将所有Tab转换为空格，需要执行以下命令：

  ```text
  :retab!
  ```

###### 自动缩进

- 在Vim中还可以进行自动缩进，主要有cindent、smartindent和autoindent三种模式。

- **autoindent** 在这种缩进形式中，新增加的行和前一行使用相同的缩进形式。可以使用以下命令，启用autoindent缩进形式。也可以点击==键进行缩进。

  ```text
  :set autoindent
  ```

- **smartindent** 在这种缩进模式中，每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（}），则取消缩进形式。此外还增加了识别C语言关键字的功能。如果一行是以#开头的，那么这种格式将会被特殊对待而不采用缩进格式。可以使用以下命令，启用smartindent缩进结构：

  ```text
  :set smartindent
  ```

- **cindent** Vim可以很好的识别出C和Java等结构化程序设计语言，并且能用C语言的缩进格式来处理程序的缩进结构。可以使用以下命令，启用cindent缩进结构：

  ```text
  :set cindent
  ```

### 标签

##### 生成标签文件

- 本节将介绍如何使用Ctag工具，来扫描代码库并生成包含关键词索引的标签文件（Tags File）。基于标签文件，Vim可以在标签之间快速跳转，并可以针对[标签自动补全](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-80-02-AutoCompletion-Detail.html%23compl-tag)。

- ctags是一个开源的命令行工具，用于从代码中索引标签（比如method, class, function等）并生成tags文件。

- 目前Ctags支持包括Vim在内的41种[编程语言](https://link.zhihu.com/?target=http%3A//ctags.sourceforge.net/languages.html)。对于vimscript脚本，其中的functions, class, commands, menu, map, variable等语法，将会作为关键字被索引至tags文件中。

- 目前ctags主要分为三个，分别为ctags、Exuberant-ctags、universal-ctags，其中ctags支持的语言较少，Exuberant-ctags支持的语言较多但是已经不维护了，universal-ctags且还在维护，我们主要使用universal-ctags

- 您可以在操作系统的命令行中使用以下命令，来验证ctags是否安装成功，并获得相关的帮助信息：

  ```bash
  $ ctags --help
  ```

- 在Vim中使用以下命令，可以针对指定的文件生成tags文件：

  ```vim
  :!ctags filename 
  ```

- 你也可以针对当前目录及其子目录中的所有文件生成tags文件：

  ```vim
  :!ctags -R .
  ```

- 将tags文件生成为其他名字

  ```
  ctags -R -f .tags
  ```

-  *ctags*是可以根据文件的扩展名以及文件名的形式来确定该文件中是何种语言，从而使用正确的分析器。可以使用如下命令来查看默认哪些扩展名对应哪些语言：

  ```
  ctags --list-maps
  ```

- 还可以指定*ctags*用特定语言的分析器来分析某种扩展名的文件或者名字符合特定模式的文件

  ```
  ctags --langmap=Ada:+.a 
  ```

- ctags是有一些额外的选项，用的时候设置一下。

###### 标签文件

- 默认生成的标签文件，是名为tags的文本文件。其开头包含若干行元数据，之后每行包含一个关键字以及与之匹配的文件名和位置信息。其中的关键字，按字母排序；并且以正则表达式作为定位信息。

  <img src="https://pic4.zhimg.com/80/v2-c6dc32fdb60a83476a1771af9459f73f_1440w.jpg" style="zoom:80%;" />

- 你可以使用`:help tags-file-format`命令，查看标签文件的格式说明。

###### 自动生成标签文件

- 利用[自动命令](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-49-01-autocmd.html)（autocmd），可以在保存文件时自动更新tags文件：

  ```vim
  :autocmd BufWritePost * call system("ctags -R")
  ```

##### 匹配单个标签

- 标签是出现在标签文件（Tags File）中的一个标识符。它是一种能够跳转的标记。例如，在 C 程序里，每个函数名都可以是一个标签。

###### 标签跳转

- 使用以下命令，可以直接跳转至定义标签的位置：

  ```vim
  :tag {name}
  ```

- 在常规模式下，使用 **Ctrl-]** 快捷键，也可以查找光标下的标签（比如函数或宏等），并跳转到定义该标签的位置。

- 在常规模式和插入模式下，按住Ctrl键并点击鼠标左键（**<C-LeftMouse>**），也可以跳转至标签定义处。

- 使用以下命令，可以在新建窗口中跳转到定义标签的位置：

  ```vim
  :stag {name}
  ```

- 在常规模式下，使用 **Ctrl-W]** 快捷键，也可以在新建窗口中跳转到定义标签的位置。

###### 标签栈

- 根据'tagstack'选项的默认设置，Vim会在标签栈中记录你跳转过的标签，以及是从哪里跳转到这些标签。

- 使用以下命令，可以查看标签栈的内容：

  ```vim
  :tags
  ```

![](https://pic4.zhimg.com/80/v2-f172a2e62e136048d54f36d0b75dd2ff_1440w.jpg)

- 使用以下不带任何参数的命令，可以跳转到较新的标签处：

  ```vim
  :tag
  ```

- 使用以下命令，可以返回到之前的标签处：

  ```vim
  :pop
  ```

- 在常规模式下，使用使用 **Ctrl-T** 键，可以依次返回之前所处的位置。

  在常规模式和插入模式下，按住Ctrl键并点击鼠标右键（**<C-RightMouse>**），也可以返回之前所处的位置。

- 使用`:h tag-stack`命令，可以查看标签栈的帮助信息。

##### 匹配多个标签

- 如果您明确知道某个标签的名称，那么可以使用[匹配单个标签](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-79-02-Tag-SingleMatch.html)章节中介绍的命令直接跳转。本节将继续介绍搜索和匹配多个标签的操作。

###### 标签搜索

- 我们可以在文件的任意位置上执行`:tag`或`:tjump`命令，以跳转至指定的标签定义处。这样就省去了将光标移动至标签之上，然后再点击跳转快捷键的繁琐。
- 如果启用了[wildmenu](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-46-02-wildmenu.html)选项，那么在输入命令时，我们只需要输入标签的开头几个字母，然后点击Tab键即可以自动补全标签名。

- 通过在命令中使用[正则表达式](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vi-81-RegularExpressionBasic.html)，可以查找符合条件的标签。例如以下命令，将查找所有以“HTML”开头的标签，并跳转至第一个匹配标签：

  ```vim
  :tag /^HTML*
  ```

- 而以下命令，将会显示所有以“Color”开头的标签，你可以选择跳转至某一匹配标签：

  ```vim
  :tjump /^Color*
  ```

- 如果有多个匹配项存在，比如在几个文件中都定义了同名的函数，那么默认情况下，将优先跳转至当前文件中的匹配项。
- 使用`:h tag-priority`命令，可以查看关于优先级的帮助信息。

###### 标签匹配列表

- 使用以下命令，将在屏幕底部显示标签匹配列表，然后根据您的选择在当前窗口中跳转至标签定义处：

  ```vim
  :tselect [name]
  ```

- 在常规模式下，使用 **g]** 快捷键，将显示与光标下标签匹配的列表：

- 使用以下命令，将在屏幕底部显示标签匹配列表，然后根据您的选择在新建窗口中跳转至标签定义处：

  ```vim
  :stselect [name]
  ```

- 在常规模式下，使用 **Ctrl-Wg]** 快捷键，将在新建窗口中，针对光标下的标签执行:tselect命令。

- 使用以下命令，可以根据匹配列表中的顺序进行标签跳转：

  - `:tnext`跳转至下一个匹配项

  - `:tprevious`跳转至上一个匹配项

  - `:tfirst`跳转至第一个匹配项

  - `:tlast`跳转至最后一个匹配项

  - 在进行标签跳转的过程中，将在屏幕底部显示其相对位置：

    ```text
    tag 1 of n or more
    ```

- 在标签的显示匹配中有以下几种，以表示是在本文件中还是全局的文件中，代表不同的匹配

  ```
  When there are multiple matches for a tag, this priority is used:
  1. "FSC"  A full matching static tag for the current file.
  2. "F C"  A full matching global tag for the current file.
  3. "F  "  A full matching global tag for another file.
  4. "FS "  A full matching static tag for another file.
  5. " SC"  An ignore-case matching static tag for the current file.
  6. "  C"  An ignore-case matching global tag for the current file.
  7. "   "  An ignore-case matching global tag for another file.
  8. " S "  An ignore-case matching static tag for another file.
  ```

###### 预览窗口

- 当我们在代码中遇到某个函数，但不太清楚其具体含义，那么可以使用 **Ctrl-]** 键跳转至函数定义处，而此时当前屏幕将会显示该函数的具体实现代码；稍后我们仍需退回到之前的位置继续编写程序。

- 如果我们希望在编辑当前代码段的同时参考具体的函数定义，那么可以使用预览窗口（Preview Window）。

- 请注意，为了使用预览窗口，Vim必须包含[QuickFix](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-70-01-QuickFix.html)特性。

- 使用以下命令，将在屏幕上方的预览窗口中显示指定标签的定义，并且保持当前光标的位置不变。也即是说，你可以同时在屏幕上查看引用函数的代码和定义函数的代码。

  ```vim
  :ptag [name] 
  ```

- 如果当前已经存在一个预览窗口，那么将重用此窗口。

- 使用 **Ctrl-W}** 快捷键，也可以针对当前光标下的标签执行:ptag命令。

- 使用以下命令，将执行:tjump命令，并在预览窗口中显示标签：

  ```vim
  :ptjump [name]
  ```

- 使用 **Ctrl-Wg}** 快捷键，也可以针对当前光标下的标签执行:ptjump命令。

- 使用以下命令，将执行:tselect命令，并在预览窗口中显示标签：

  ```vim
  :ptselect [name]
  ```

- 使用以下命令，可以在预览窗口中进行标签跳转：
  - `:ptnext`在预览窗口中执行:tnext命令
  - `:ptprevious`在预览窗口中执行:tprevious命令
  - `:ptfirst`在预览窗口中执行:tfirst命令
  - `:ptlast`在预览窗口中执行:tlast命令
  - `:ppop`在预览窗口中执行:pop命令
  - `:pclose`关闭预览窗口
- 使用 **Ctrl-Wz** 快捷键，也可以关闭预览窗口。

###### 位置列表

- 使用以下命令，可以跳转到指定标签，并在当前窗口的新位置列表中加入匹配的标签：

  ```vim
  :ltag [name]
  ```

- 使用以下命令，可以显示位置列表：

  ```vim
  :lopen 
  ```

- 例如，首先使用`:ltag /^HTML*`命令，查找所有以“HTML”开头的标签并将它们放入到位置列表当中；然后使用`:lopen`命令，查看位置列表。

  ![](https://pic1.zhimg.com/80/v2-fb80c8af8398da117f190a26e255c8b8_1440w.jpg)

- 使用以下命令，可以在位置列表中进行标签跳转：
  - `:lnext`移动到下一个标签
  - `:lprevious`移动到下一个标签
  - `:lfirst`移动到第一个标签
  - `:llast`移动到最后一个标签
  - `:lclose`关闭位置列表

###### 智能跳转

- 看了这么多命令，是不是已经心烦意乱了？我们期待的理想状况应该是：如果只有一个匹配标签，那么直接跳转；如果发现多个匹配标签，则显示匹配列表。
- 使用`**:tjump {name}**`命令，如果只发现一个匹配标签，将直接跳转至标签定义处；如果发现多个匹配标签，那么将显示标签匹配列表。
- 在常规模式下，使用 **gCtrl-]** 快捷键，将针对光标下的标签执行:tjupm命令。
- 使用`**:stjump**`命令，则可以在新建窗口中执行:tjupm命令。
- 在常规模式下，使用 **Ctrl-W g Ctrl-]** 快捷键，将针对光标下的标签在新建窗口中执行:tjupm命令。

##### 标签选项

- 通过'tags'选项，可以指定查找标签文件的位置。根据以下默认设置，Vim将在当前目录查找标签文件：

  ```vim
  set tags=./tags,tags
  ```

- 对于大量的代码文件，也可以设置更精细的查找路径：[[S\]](https://www.zhihu.com/question/47691414/answer/373700711)

  ```vim
  set tags=./.tags;,.tags
  ```
  - 其中，以逗号分隔的参数为：
    - ./.tags;，代表在文件的所在目录下，查找名字为“.tags”的标签文件。使用以点开头的文件名，以便与常规的项目文件相区别。结尾的分号代表查找不到时继续向上递归到父目录。这样对于分布在不同子目录中的源代码文件，只需要在项目顶层目录放置一个.tags文件即可。
    - .tags，是指同时在 Vim 的当前目录（即:pwd命令返回的目录）下查找 .tags 文件。
    - 上面两种的区别是，一个是文件所在的目录下tags文件，一个是在当前pwd目录下，区别在于我们可以在当前目录下用vim看其他目录的文件。所以会有这个区别。
    - 上面中没有分号就只会在文件的所在目录下查找tags文件，并不会向上递归查找。

- 假设我们针对rails源码库（*~/src/rails*）生成tags文件，并在'tags'选项中包含此文件，那么就可以在编写代码时，方便地跳转至标签的定义处，获得相关地使用说明。

  ```vim
  set tags+=~/tags/rails.tags
  ```

- 默认设置下，Vim使用二分法（binary search）来查找指定的标签名。如果您生成的[标签文件(Tags File)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-79-01-Tag-File.html)没有经过排序，那么可以切换至线性查找（linear search）方式：

  ```vim
  :set notagbsearch
  ```

###### 标签函数

- 通过调用Vim内置的taglist函数，可以实现自定义的标签匹配功能。taglist函数将根据输入的正则表达式，将所有匹配的标签以列表形式返回。使用`:help taglist`命令，可以查看该函数的帮助信息。

- 例如以下代码，利用taglist函数实现了查找指定函数的功能：

  ```vim
  command! -nargs=1 TagFunction call s:TagFunction(<f-args>) 
  function! s:TagFunction(name)
     " Retrieve tags of the 'f' kind 
     let tags = taglist('^'.a:name)
     let tags = filter(tags, 'v:val["kind"] == "f"')
     " Prepare them for inserting in the quickfix window
     let qf_taglist = []   
     for entry in tags
         call add(qf_taglist, {
              \ 'pattern':  entry['cmd'],
              \ 'filename': entry['filename'],
              \ })
     endfor
     " Place the tags in the quickfix window, if possible
     if len(qf_taglist) > 0 
        call setqflist(qf_taglist)
        copen
     else
        echo "No tags found for ".a:name
     endif
  endfunction 
  ```
  - 使用`:TagFunction HTML`命令调用自定义函数，将查找所有以“HTML”开头的函数，并显示在[Quickfix](https://link.zhihu.com/?target=https%3A//yyq123.github.io/learn-vim/learn-vi-70-01-QuickFix.html)中。

    ![](https://pic1.zhimg.com/80/v2-eb26afcde9caa4cf923d812c80ca78c4_1440w.jpg)

###### 标签相关插件

- [unimpaired.vim](https://link.zhihu.com/?target=http%3A//www.vim.org/scripts/script.php%3Fscript_id%3D1590)插件，映射了一系列方括号开头的快捷键，以方便在标签之间进行跳转。比如]t代表`:tnext`；[t代表`:tprev`等等。
- [vim-gutentags](https://link.zhihu.com/?target=https%3A//github.com/ludovicchabant/vim-gutentags)插件，可以检测文件变动并自动增量更新[标签文件](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-79-01-Tag-File.html)（Tags File）。它可以异步更新标签，并且对于标签文件进行排序，以便于Vim使用二分法快速搜索关键字。

### 正则表达式

##### 正则表达式命令

- Vim提供以下两种grep（globally search a regular expression and print）搜索工具：

  - `:vimgrep` 使用Vim内置的grep实现；

  - `:grep` 调用外部的grep工具。

- :grep命令会运行由选项grepprg所指定的程序。在Linux系统上，grepprg默认是[grep](https://link.zhihu.com/?target=http%3A//www.gnu.org/software/grep/manual/grep.html) -n：

- 在Windows系统上，grepprg默认是[findstr](https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/windows-server/administration/windows-commands/findstr) /n

- :vimgrep命令使用vim内置的搜索引擎，与`/`命令功能一致，但速度相对较慢。

- 由此可见，使用:vimgrep命令在不同平台上将获得一致的体验。而:grep命令则是与操作系统相关的，在不同平台会有不同的行为。

- `:grep`和`:vimgrep`命令，都将在[QuickFix](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-70-01-QuickFix.html)中显示搜索结果。

- `:lgrep`和`:lvimgrep`命令实现相同的功能，但使用地址列表（Location List）来显示匹配结果。

- 使用`:copen`命令打开的Quickfix，是全局性的。而使用`:lopen`打开的Location List，则是独立存在于各个窗口中的。

- 对于Quickfix，使用`:cp`命令，跳转到上一个匹配处；使用`:cn`命令，跳转到下一个匹配处。

- 对于Location List，使用`:lpre`命令，跳转到上一个匹配处；使用`:lnext`命令，跳转到下一个匹配处。

###### vimgrep

- 使用以下命令，可以在当前目录下查找指定字符串：

  ```vim
  :vimgrep grep *
  ```

- 如果希望在当前目录及其子目录中进行查找，那么可以使用**通配符：

  ```vim
  :vimgrep blue **
  ```

- 以下命令将在当前目录及其子目录中的所有HTML文件中，查找指定字符串：

  ```vim
  :vim blue **/*.html
  ```

- 请注意，:vimgrep命令可以缩写为`:vim`。

- 首先在常规模式下，使用`*`命令查找光标下的单词；然后使用以下命令，可以重用之前的查找：

  ```vim
  :vim // *.html
  ```

- 默认情况下，将自动跳转至第一个匹配处；如果希望停留在当前位置，那么可以在命令中使用j参选：

  ```vim
  :vimgrep /foo/j **/*.md
  ```

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help :vimgrep
  ```

###### grep

- 使用以下命令，将在当前目录下查找所有文件：

  ```vim
  :grep block *.*
  ```

- 默认情况下，grep是区分大小写的，可以使用-i选项来忽略大小写：

  ```vim
  :grep -i word filename
  ```

- 使用-o选项，将只显示匹配的字符，而不是整行内容：

  ```vim
  :grep -o [[:punct:]] filename
  ```

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help :grep
  ```

- 请注意，递归搜索子目录的 `**/*.*` 通配符，对于Linux下的:vimgrep和:grep命令有效；但对于Windows下的:grep命令不起作用。

###### grepprg选项

- 使用以下命令，可以查看'grepprg'选项的当前设置：

  ```vim
  :set grepprg?
  ```

- 在不同的操作系统下，Vim将默认使用不同的外部grep工具：
  - 在Windows下
    `grepprg=findstr /n`
  - 在Linux下
    `grepprg=grep -n $* /dev/null`

- 如果希望默认查询当前目录以及其子目录，那么可以使用以下设置：
  - 在Windows下
    `set grepprg=findstr /S /n`
  - 在Linux下
    `set grepprg=grep -nR $* /dev/null`

- 使用以下命令，可以查看更多帮助信息：

  ```
  :help 'grepprg'
  :help pattern
  ```

- 关于正则表达式的更多信息，可以参考以下网站：

  - [Vim Regular Expressions 101](https://link.zhihu.com/?target=http%3A//vimregex.com/)
  - [Regular-Expressions.info](https://link.zhihu.com/?target=https%3A//www.regular-expressions.info/)

- 使用以下网站，可以视觉化正则表达式，以便分步理解复杂的表达式：

  - [REGEXPER](https://link.zhihu.com/?target=https%3A//regexper.com/)
  - [Regular Expressions 101](https://link.zhihu.com/?target=https%3A//regex101.com/)

##### 正则表达式基础

###### 行首与行尾

- **^acme**，将匹配以acme开始的行。注意：除非出现在模式的开头，否则音调符号^就不是一个代表行开头的通配符，而会代表其他的含义。2^4，将匹配包含"2^4"的所有行。如果要查找以“^”开头的行，则需要使用^^模式。其中第一个^是通配符用于指示一行的开头，而第二个^则是实际的音调符号。如果要指明前导^是一个实际的音调符号而不是表示一行开头的通配符，那么就需要在其前面加一个转义的反斜杠“\”来组成\^acme模式。

- **acme$**，将匹配以acme结尾的行。^acme$，将匹配只包含acme一个单词的行。而^$，则会匹配所有空行。

- **dog.bone**，将匹配dog-bone，dog bone，dog/bone，但不会匹配dogbone，因为dog和bone之间并没有分隔符。其中.表示匹配任一字符

- 要指示任何字符出现的次数，可以同时使用句点和星号（.*），例如dog.*bone将匹配以下字符串（但不会匹配dog在一行而bone在另一行的情况）：

  ```
  dogbone
  dog-bone
  doggy bone
  My dog has a bone
  ```

###### 词尾与词首

- **<**用于匹配一个单词的开始。**>**用于匹配一个单词的结束。也就是说，只要将想要查找的字符串包围其中，就可以实现精确查找。例如在文件中有单词Californian和Unfortunately。如果使用命令**/for**来查找，那么也会找到这两个单词。

  ![](https://pic3.zhimg.com/80/v2-3ca758146256a15b49c14ee21133d4b2_720w.png)

- 如果使用表达式`/\<for\>`来进行查找，则只会精确的查找到for，而不会出现其他的匹配。

###### 匹配次数

- 星号（\*）通配符，作用于其之前的一个元素，表示可以匹配0次或是多次。表达式的贪婪（greedy）特性，将尝试查找尽可能多的匹配项。te*将会匹配te，tee，teee等等。甚至还会匹配t，因为在这里e可以出现0次。
- 加号（+）通配符，表示一个字符可以匹配一次或是多次。所以表达式te\+可以匹配te，tee，teee等等。但是不会再匹配t，因为这里e最少要出现一次。
- 等号（=）通配符，表示一个字符匹配0次或是一次。所以表达te\=可以匹配t和te，但是不会匹配tee，因为这个表达式只能匹配不多于两个字符。

##### 正则表达式进阶

###### 范围

- **[]**通配符，表示只可以匹配方括号内列表的字符。例如**t[aeiou]n**将匹配一个小写元音字符，可以找到tan,ten,tin,ton,tun。
- 在方括号内，可以通过短横线来指明包括字符或数字的范围。例如**[0-9]**可以匹配0到9中的任一数字。我们还可以组合其他字符，例如**[0-9aeiou]**可以匹配任意一个数字或是小写的元音字符。
- 如果需要匹配"-"本身，那么需要使用反斜杠进行转义。例如表达式**`one[\-]way`**可以匹配one-way，但不会匹配one way。

###### 排除

- **^**通配符，可以排除指定的字符。
- **`acme[^0-9]`**匹配所有包含acme，后跟一个非数字字符的行。但不会匹配以acme结尾的行，因为模式中的acme之后必须有一个字符。
- **`^[^a-zA-Z]`**匹配以非字母开头的行，但不会匹配空行，因为行中必须有一个非字母字符存在。

- 如果需要匹配"^"本身，那么需要使用反斜杠进行转义。例如表达式**2[\^\*]4**可以匹配2^4和2*4。

###### 重复次数

- **{minimum,maximum}**表达式指出一个字符重复的次数。例如表达式**`a\{3,5}`**可以匹配3到5个a（aaa，aaaa，aaaaa）。Vim默认是会尽可能多地进行匹配（Matching as much as possible）。在表达式中，最小次数是可以省略的，即默认最小次数为0，所以表达式**`a\{,5}`**可以匹配0到5个a。最大次数也是可以省略的，即默认匹配无穷大，所以表达式**`a\{3,}`**最少可以匹配3个a，最多个数没有限制。

- **{number}**表达式只指定一个数字，Vim就会精确的匹配相应的次数。例如**`a\{5}`**只会精确的匹配5次。

- **{-minimum,maximum}**在数字前增加一个负号(-)，那么Vim在查找时就会尽可能少地进行匹配（Matching as little as possible）。例如**`ab\{-1,3}`**将只匹配 "abbb"中的"ab"。表达式**`a\{-3,}`**可以匹配三个或是更多个a，但尽可能少地进行匹配。而表达式**`a\{-,5}`**可以匹配0到5个字符。

- 表达式**`a\{-5}`**将会精确的匹配5个字符。

  ![](https://pic1.zhimg.com/80/v2-63fea3e184ee2c5602d100a7e52bfefc_720w.png)

###### 捕获组

- ()用于保证需要组合出现的字符。表达式**`a\(XY\)*b`**将会匹配ab, aXYb, aXYXYb, aXYXYXYb。

###### 或操作

- |用于查找两个或是多个可能的匹配。例如表达式**`foo\|bar`**可以找到foo或是bar。我们可以连接使用多个或运算符，例如表达式**`Larry\|Moe\|Curly`**将找到Larry、Moe和Curly。而表达式**`end\(if\|while\|for\)`**则可以匹配"endif", "endwhile" 和 "endfor"几个不同的元素组合。
- 如果希望匹配多次，那么可以组合使用加号和括号运算符。例如表达式**`/\(foo\|bar\)\+`**可以匹配 "foo", "foobar", "foofoo", "barfoobar"等等。

###### 特殊字符元素

![](https://pic3.zhimg.com/80/v2-220a079d462a4c7da5044644f13788f6_720w.png)

- 表达式**\a**匹配任意字符，而表达式**\a\a\a**则可以匹配任意三个字符。而**\a\a\a_**则可以匹配任意后带一个下划线的三个字符。

- 操作符**\d**可以匹配任意数字；**\d\d\d\d**则可以匹配任意四个数字（即使其为更长数字串中的一部分）。

- 如果希望精确匹配四位数字，那么可以使用以下任一命令：

  ```vim
  /\<\d\d\d\d\>
  /\<\d\{4}\>
  ```

- **\u**可以匹配任意大写字符；**\U**则可以匹配任意非大写字符。使用以下命令，可以将整篇文本替换为大写字母：

  ```vim
  :%s/.*/\U&/
  ```

- 如果需要找出包含空格的空行，那么可以使用**^\s.\*$**表达式；如果需要找到没有空格的空行，则可以使用**\S**

- **\s\+$**可以匹配尾部的空格； **\+\ze\t**则可以匹配Tab制表符之前的空格。（请注意，此表达式开头为空格）
- 请注意，以上预定义字符是不能内嵌在[]中使用的。例如，表达式[\d\l]是错误的，应使用**\(\d\|\l\)**表达式匹配数字或小写字符。

###### 预定义字符类

- 如果我们想要查找所有大写字符，可以使用表达式**[A-Z]**，或者使用预定义的字符类[:upper:]。使用**/[[:upper:]]**命令可以匹配所有大写字母；而使用**`/[[:upper:][:lower:]]`**命令则可以匹配包括大写和小写字母在内的所有字母。

![](https://pic4.zhimg.com/80/v2-19e8fba1611f264b656058615e84632b_720w.png)

###### 转义符

- 如果需要查找某些特殊符号（比如美元符号），那么可以使用反斜杠backslash（\）进行转义。例如：表达式**\$**可以匹配美元符号（$），而表达式**\^**则可以匹配脱字符（^）。需要注意的是，反斜杠backslash（\）本身也是特殊符号，所以需要用两个反斜杠\\来匹配。

###### 帮助信息

- 可以使用以下命令，查看关于查找模式的更多帮助信息：

  ```vim
  :help pattern
  ```

##### 捕获组

- `()`用于保证需要作为整体而组合出现的字符。例如表达式`a\(XY\)*b`将会匹配ab, aXYb, aXYXYb, aXYXYXYb。
- 逆向引用（Back Reference）表达式`\n`，用于引用之前定义的第n个捕获组。其中n为数字1–9。
- 例如对于文本“he fly fly flies”，表达式`\(fly\) \1`将匹配“fly fly”。因为`\1`再次引用了第一个捕获组“fly”，所以将匹配2个“fly”。、

###### 捕获组匹配

<img src="https://pic2.zhimg.com/80/v2-ac093c29ff9cec91690036f0bdfe1a71_720w.jpg" style="zoom:67%;" />

- 假设需要查找以上多种格式的电话号码，其中：

  - 可能包含区号，也可能没有区号；
  - 区号由3位数字组成；
  - 区号可能被括号包围，也可能没有括号；
  - 区号和号码之间，可能有横线或者空格相连，也可能没有任何连接符；
  - 号码由3位数字，横线连接符，和4位数字组成。

- 使用以下命令，可以满足以上格式需求：

  ![](https://pic4.zhimg.com/80/v2-2a229df815be2abf67960287676264c7_720w.jpg)

- 由此可见，将区号及其后的连接符作为一个整体捕获为组，这样就可以通过后续的 \? 表达式来匹配0个或1个捕获组，以实现匹配包含区号和不包含区号的多种情况。

###### 捕获组嵌套

- 以下文本中包含FIRSTNAME LASTNAME格式的姓名信息：

  ```text
  Prepared by Tommas Young
  Prepared by Tommy Young
  ```

- 使用以下命令，可以将其转换为LASTNAME, FIRSTNAME格式：

  ```vim
  :%s/\(Tom\%(mas\|my\)\) \(Young\)/\2, \1/g
  Prepared by Young, Tommas
  Prepared by Young, Tommy
  ```

- 从以上命令可以看到，捕获组是可以嵌套的；\%(\) 指定的组将不会被计数，这可以允许我们使用更多的组，并且查找速度也更快。

###### 捕获组替换

- 假设需要将以下文本中的单引号替换为双引号：

  ```text
  The string contains a 'quoted' word.
  The string contains 'two' quoted 'words'.
  The 'string doesn't make things easy'.
  The string doesn't contain any quotes, isn't it.
  ```

- 通过以下命令中的嵌套捕获组来完成替换操作：

  ```vim
  :%s/\s'\(\('\w\|[^']\)\+\)'/ "\1"/g
  The string contains a "quoted" word.
  The string contains "two" quoted "words".
  The "string doesn't make things easy".
  The string doesn't contain any quotes, isn't it.
  ```

- 其中，\s' 用于匹配紧跟在空格之后即单词开头的单引号；\('\w\|[^']\) 则将非开头的单引号视为单词的一部分，以防止其被替换位双引号。

###### 替换字符串中的元字符

- 在替换和全局命令中， 某些元字符（metacharacters）在查找表达式和替换表达式中的含义是不同的。

- 例如以下命令，查找部分中的“.”因为有特殊意义，所有需要进行转义；而替换部分中的“.”和“$”则会被视为普通文本。

  ```
  :%s/1\. Start/2. Next, start with $100/
  ```

- 例如以下命令，会将“A”或“B”或“C”，分别替换为“[abc]”。也就是说，“[]”在替换部分也会被视为普通文本。

  ```vim
  :%s/[ABC]/[abc]/g
  
  ABC --------> [abc][abc][abc]
  ```

##### 替换表达式中的元字符

![](https://pic1.zhimg.com/80/v2-e76122c7eae10a9a6f4ed69df6213b7c_720w.jpg)

###### 使用元字符交换文本位置

- 使用以下命令，可以交换以逗号分隔的列：

  ```vim
  :%s/\([^,]*\),\([^,]*\),\(.*\)/\2,\1,\3/
  ```

![](https://pic1.zhimg.com/80/v2-cc2b9f8773c97b64ae109b629cd164dc_720w.jpg)

- 查找表达式包括：
  - \([^,]*\)，匹配除逗号之外的所有字符，即将第一列的内容捕获为组1；
  - \([^,]*\)，匹配除逗号之外的所有字符，即将第二列的内容捕获为组2；
  - \(.*\)，匹配剩余的所有字符，捕获为组3；

- 替换表达式包括：

  - \2,\1,\3，按照组2组1组3的顺序恢复各组的内容，即交换第二列与第一例的次序。

- 请注意，作为分隔符的逗号，在查找和替换部分均被视为普通文本。

- 假设需要将以下记录中的Name字段，转换为Firstname Lastname的形式：

  ```text
  Name: McFly, Susan S.; Areas: Graphics; Phone: 999-3333
  ```

  - 可以使用以下命令，将逗号之前的Lastnmae捕获至组1，将分号之前的Firtname捕获至组2，然后再按照从组2到组1的顺序进行替换：

    ```vim
    :%s/: \([^,]*\), \([^;]*\);/: \2 \1;
    ```

    ```text
    Name: Susan S. McFly; Areas: Graphics; Phone: 999-3333 
    ```

  - 使用以下全局命令，则可以将替换操作限制在以“Name:”开头的行：

    ```vim
    :g/^Name/s/: *\([^,]*\), \([^;]*\);/: \2 \1;/
    ```

###### 使用元字符转换大小写

- 使用以下命令，将单词首字母转换为大写：

  ```vim
  :%s/\<\(.\)\([^[:space:][:punct:]]*\)\>/\u\1\2/g
  ```

![](https://pic1.zhimg.com/80/v2-351443719c5a28f4c24ef677437d4a84_720w.png)

- 查找表达式包括：

  - \<，匹配单词开头；
  - \(.\)，匹配单词首字母，捕获为组1；
  - \([^[:space:][:punct:]]*\)，匹配除空格和标点符号之外的字符串，即将单词首字母之外的其余部分捕获为组2；
  - \>，匹配单词末尾；

- 替换表达式包括：

  - \u，将下一个字符转换为大写；
  - \1，恢复捕获组1（即单词首字母）
  - \2，恢复捕获组2（即单词剩余部分）

- 使用以下命令，可以将匹配文本全部转换为大写：

  ```text
  :%s/Fortran/\U&/
  fortran --------> FORTRAN
  ```

###### 使用元字符进行精确替换

- 假设以下代码中rotine的名称以“test”为前缀，以“box”为后缀，而黄色高亮的中间部分则是可变的：

  ![](https://pic2.zhimg.com/80/v2-a74545420f92cfa727560710d4a961e1_720w.jpg)

- 如果希望将后缀替换为“block”，那么可以将可变的字母作为捕获组进行替换：

  ```vim
  :g/test\([abc]\)box/s//test\1block/g
  ```

![](https://pic4.zhimg.com/80/v2-c9c56c82e29ec1fa873a1ff200987f87_720w.jpg)

- 假设需要将代码中“?dep=01”替换为：

  ```text
  {{path('index',{dep:01})}}
  ```

- 也就是说，只替换表达式的字符部分，但保留数字部分不变。可以使用(\d\d)捕获两位数字部分，然后在替换时使用\1来恢复数字：

  ```vim
  :%s/?dep=\(\d\d\)/{{path('index',{dep:\1})}}/g 
  ```

##### 替换字符串中的submatch()

- `submatch({nr})`函数，只用于 :substitute 命令或 substitute() 函数中。它将返回匹配文本的第{nr}个子匹配。如果{nr}为0，则返回整个匹配文本。
- 将submatch()和其它函数相结合，可以对替换文本进行更丰富的操作。使用`:help submatch()`命令，可以查看更多帮助信息。

###### 更新列表序号

- 如果希望在第1条之后插入一个新的条目，那么就意味着需要调整后续各个条目的序号：

  ```text
  Article 1: 3 Steps To Enable Thesaurus Option
  Article 2: Steps to Add Custom Header
  Article 3: Automatic Word Completion
  Article 4: How To Record and Play Macro
  Article 5: Make Vim as Your C IDE
  ```

- 使用以下命令，将第2行及之后各行中的序号分别加1：

  ```vim
  :2,$s/\d\+/\=submatch(0) + 1/
  ```

  ```text
  Article 1: 3 Steps To Enable Thesaurus Option
  Article 3: Steps to Add Custom Header
  Article 4: Automatic Word Completion
  Article 5: How To Record and Play Macro
  Article 6: Make Vim as Your C ID
  ```

- 请注意，替换命令中并没有使用/g标志，因此将仅仅替换第一个匹配字符，以避免条目文本中的数字也被更改。

###### 转换单词大小写

- 假设需要在以下条目中，将首个单词的首个字母转换为大写：

  ```text
  The following activities can be done using vim:
  a. source code walk through,
  b. record and play command executions,
  c. making the vim editor as ide
  ```

- 使用以下命令，将匹配“.”及空格之后的单词字符（0-9A-Za-z），并替换为大写：

  ```vim
  :%s/\.\s*\w/\=toupper(submatch(0))/g
  The following activities can be done using vim:
  a. Source code walk through,
  b. Record and play command executions,
  c. Making the vim editor as ide
  ```

###### 替换文件路径

- 将当前光标下的相对路径名，替换为完整的绝对路径名：

  ```vim
  :s/\f*\%#\f*/\=fnamemodify(submatch(0), ':p')/
  ```

  - 其中，\= 表示使用表达式作为替换字符串（请参考帮助信息`:help sub-replace-expression`）；\f*\%#\f* 将匹配文件名（请参考帮助信息`:help /\f`） 。

- 如果希望将可视化模式下选中的文件名，替换为完整的绝对路径名，那么在命令中使用\%V参数：

  ```vim
  :s/\%V.*\%V/\=fnamemodify(submatch(0), ':p')/
  ```

###### 数据补零

- 将每行数据中不满8位的字符串，向右对齐并在前部以0补足8位：

  ```vim
  :%s/.*/\=printf('%08s',submatch(0))/g
  ```

![](https://pic3.zhimg.com/80/v2-0fd3d9d605d6042dfac214640c5d97ea_720w.jpg)

##### 4种magic模式

- 根据对于特殊元字符的不同解释方式，Vim正则表达式可以分为四种模式：magic，no magic，very magic和very nomagic。

  - **[magic](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-86-Magic.html)**模式，使用`\m`前缀，其后模式的解释方式为'magic'选项。`^`，`$`，`.`，`*`和`[]`等字符含有特殊意义；而`+`、`?`、`()`、和`{}`等其它字符则按字面意义解释。magic为默认设置，表达式中的\m前缀可以省略；
  - **[no magic](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vi-86-Magic.html)**模式，使用`\M`前缀，其后模式的解释方式为'nomagic'选项。除了`^`和`$`之外的特殊字符，都将被视为普通文本；
  - **[very magic](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vim-Regex-VeryMagic.html%23regex-very-magic)**模式，使用`\v`前缀，其后模式中除 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字符都当作特殊字符解释；
  - **[very nomagic](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vim-Regex-VeryMagic.html%23regex-very-no-magic)**模式，使用`\V`前缀，其后模式中只有反斜杠（`\`）具有特殊意义。

- 不同模式之间的区别，在于哪些特殊字符需要使用反斜杠（`\`）进行转义。例如星号（*），在magic和very magic模式下视为特殊修饰符；而在no magic和very nomagic模式下则被视为普通字符，必须使用“\*”恢复其特殊作用。

- 对于简单的正则表达式，使用“\”对特殊字符进行转义，可能并不会造成困扰；但在复杂的正则表达式中，对大量特殊字符的重复转义，将使得表达式过于繁琐且难以阅读。

- 例如在默认的magic模式下，使用以下命令查找十六进制色彩值。其中，使用`()`构建[捕获组](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vim-Regex-Groups.html)；使用`{}`匹配6位和3位十六进制值。因为有多种特殊字符需要进行转义，造成表达式过于冗长：

  ```vim
  /\m#\(\x\{6\}\|\x\{3\}\)
  ```

  - 而使用very magic模式，则可以简化表达式：

    ```vim
    /\v#(\x{6}|\x{3})
    ```

- 4种Magic模式的差异和用法，可以简单总结如下：

  ![](https://pic2.zhimg.com/80/v2-6b5c9e9dd2feafceedf0aedeaed3e141_720w.jpg)

- 以下表格，列示了常用特殊字符在不同模式下的应用。其中，黄色高亮表示为无需转义的特殊字符：

  ![](https://pic4.zhimg.com/80/v2-c0a945e07ad16064adb6a33db9a59dc3_720w.jpg)

- 请注意，”`\{\}`“也可简写为”`\{}`“；”`\[]`“必须仅保留开头的反斜杠；”`\(\)`“则需要完整的两个反斜杠。（感谢[liouperng](https://www.zhihu.com/people/liouperng)指教）

###### magic默认模式

- 建议始终将['magic'](file:///E:/Anthony_GitHub/learn-vim/options.html#'magic')选项保持在缺省值。

- 建议在模式之前，通过使用“\v“或“\M“等前缀，来明确激活特定模式。

- 如果希望始终使用Very magic模式，那么请在vimrc中定义以下键盘映射，将在查找和替换时自动激活very magic模式：

  ```vim
  nnoremap / /\v
  vnoremap / /\v
  cnoremap %s/ %s/\v
  nnoremap :g/ :g/\v
  ```

###### 模式转换

- 你甚至可以在表达式当中改变模式。例如以下命令，开头使用very magic模式，之后转换为magic模式，整体表达式将匹配“foo(bar)”：

  ```vim
  /\vfoo\(\mbar)
  ```

- 当然，非常不建议采用此种易引起误解的表达式写法。我们可以将其改写为very nomagic模式：

  ```vim
  /\Vfoo(bar)
  ```

- 请使用以下命令，查看更多帮助信息：

  ```vim
  :help /magic
  ```

##### magic模式

###### magic选项

- 默认情况下，magic选项是打开的。如果关闭了此选项，那么正则表达式中的许多的特殊字符就失去了他们神奇的魔力，而变成了普通的字符。

- 我们使用以下只有一行的文件来测试magic选项。先用:%print命令将整个文件打印出来:

  ```text
  Test aaa* aa* a*
  ```

- 然后设置magic选项并且执行替换命令。其中，*p*标记打印出所改变的行:

  ```vim
  :set magic
  :1 substitute /a*/b/p
  ```

- 命令的执行结果如下:

  ```text
  bTest aaa* aa* a*
  ```

- 命令只是改变了一行开始的部分。为什么会将Test变为b*Test呢？这是因为*可以匹配0次或是多次，而Test正是以0个a开始的。为什么只是替换了一次呢？这是因为:substitute命令中是改变第一个出现的地方，如果我们使用*g*标记就可以替换全部的匹配项了。如果希望g标记成为默认设置，那么可以使用:set gdefault命令。

- 我们撤销刚才的命令并再次执行替换命令:

  ```vim
  :undo
  :1 substitute /a*/b/pg
  ```

- 命令的执行结果如下:

  ```text
  bTest b*b b*b b*
  ```

- 如果在关闭magic选项的情况下再次执行命令:

  ```vim
  :undo
  :set nomagic
  :1 substitute /a*/b/pg
  ```

- 命令的执行结果如下:

  ```text
  Test aab ab b
  ```

###### smagic命令

- :smagic命令，可以在执行替换命令时强制转换*等特殊字符的意义。例如我们执行以下命令:

  ```vim
  :smagic /a*/b/pg
  ```

- 命令的执行结果如下:

  ```text
  bTest b*b b*b b*
  ```

- :snomagic命令，强行关掉magic选项:

  ```vim
  :snomagic /a*/b/pg
  ```

- 命令的执行结果如下:

  ```text
  Test aab ab b
  ```

##### very magic模式

- 假设希望在以下CSS代码中，查找所有颜色代码：

  ```text
  body { color: #3c3c3c; }
  strong { color: #000; }
  ```

- 在默认的Magic模式下，使用以下命令可以匹配以“#”开头的十六进制色彩值：

  ```vim
  /#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)
  ```

- 在以上正则表达式中，`[]`用于指定可选字符范围，但不需要转义；`()`用于构建[捕获组(Groups)](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim-Regex-Groups.html)，需要使用`\`进行转义；`{}`用于指定重复次数，但只需要对开括号进行转义，与之对应的闭括号可以不用转义。由此可见，在Magic模式下，需要对很多特殊符号进行转义，而且转义的方式也欠缺一致性。在编写较复杂的正则表达式时，显得琐碎且难以阅读。

- 使用`\v`激活Very Magic模式，则可简化为更加友好的正则表达式：

  ```vim
  /\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})
  ```

![](https://pic1.zhimg.com/80/v2-1aef1e9ad96e727f58ab665768936578_720w.jpg)

###### very magic

- 在模式开头使用`\v`激活very magic模式，其后除下划线（_）、大小写字母以及数字之外的所有字符都具有特殊含义。这样可以避免重复输入大量的转义符（\），也使得正则表达式更加清晰易读。

- 假设在以下文本中，希望搜索单引号包围的内容：

  ```text
  you have mocking some 'bird of the year'.
  you have mocking some 'the year's bird'.
  ```

- 在默认的magic模式下，使用以下模式来处理单词中的单引号：

  ```vim
  /'\('\w\|[^']\)\+'
  ```

![](https://pic1.zhimg.com/80/v2-6355f5a8adf4b6790c332d24d098e268_720w.jpg)

- 如果使用VeryMagic模式，命令则可以简化为：

  ```vim
  /\v'('\w|[^'])+'
  ```

- 假设在以下文本中，希望仅保留英文字母：

  ```text
  12345aaa678
  12345bbb678
  12345ccc678
  ```

- 使用以下替换命令，可以删除其中的数字部分：

  ```vim
  :%s/\d\{5\}\(\D\+\)\d\{3\}/\1/
  aaa
  bbb
  ccc
  ```

- 如果使用VeryMagic模式，命令则可以简化为：

  ```vim
  :%s/\v\d{5}(\D+)\d{3}/\1/
  ```

- 由此可见，Very magic模式为使用正则表达式提供了极大的便利。但很不幸，我们并无法将Very magic模式设置为默认选项。潜在的替代方案是，定义以下键盘映射，在查找时自动激活very magic模式：

  ```vim
  :noremap / /\v
  ```

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help /\v
  ```

###### very no magic

- 在模式开头使用`\V`指定Very No Magic模式，将使得其后模式中只有反斜杠（\）具有特殊意义，而`()`、`[]`、`|`、`.`、`*`和`?`等等元字符都将被视为普通文本。

- 如果您需要精确的完整匹配，并且查找字符串中包含特殊字符时，那么可以使用Very nomagic模式。

- 例如以下命令，将查找字符串“Fun.test(*args)” 。也就是说，其中的“*”和“.”都被视为普通字符，而不需要进行转义：

  ```vim
  /\VFun.test(*args)
  ```

- 假设需要在以下文本中查找“a.k.a”：

  ```text
  The N key searches backward
  the \v pattern switch (a.k.a. very magic)
  ```

- 因为“.”在正则表达式中具有特殊含义，它将会匹配任意字符，所以使用以下命令，将会同时匹配单词“backward”中的部分字符：

  ```vim
  /a.k.a
  ```

![](https://pic4.zhimg.com/80/v2-cc7f6d37319da1136a00f47a7da128ab_720w.jpg)

- 当然，可以使用转义符来消除“.”的特殊含义：

  ```vim
  /a\.k\.a\.
  ```

- 而更简单的方法是，在命令中使用`\V`激活very nomagic模式：

  ```vim
  /\Va.k.a.
  ```

- 此时，将只会按字面匹配到单词“a.k.a”：

  ![](https://pic3.zhimg.com/80/v2-8633d2f88c48bc7930eebb6776222e86_720w.jpg)

- 使用以下命令，可以查看更多帮助信息：

  ```vim
  :help /\V
  ```

- 我们可以将 very magic 和 very nomagic 模式，理解为对于正则表达式的两种极端处理方式。需要构建较复杂正则表达式时，推荐使用very magic模式；需要按字面意义查找文本时，则推荐使用very nomagic模式。

##### 正则表达式实例

###### 匹配空格

- 删除所有行首的空格：

  ```vim
  :%s/^□□*\(.*\)/\1/
  ```

  其中，使用^□□*查找行首的一个或多个空格；而\(.*\)将行中的其它内容捕获为组；在替换部分使用\1来恢复捕获组。

- 删除所有行尾的空格：

  ```vim
  :%s/\(.*\)□□*$/\1/
  ```

  - 其中，使用□□*$查找行尾的一个或多个空格；而\(.*\)将行中的其它内容捕获为组；在替换部分使用\1来恢复捕获组。

- 将多个空格替换为一个空格：

  ```vim
  :%s/□□*/□/g
  ```

  - 其中，第一个□代表一个实际的空格，而□*则会匹配零个或多个空格。

- 将冒号或句点之后的多个空格，替换为一个空格：

  ```vim
  :%s/\([:.]\)□□*/\1□/g
  ```

  - 其中，方括号内的的特殊字符（比如.）并不需要转义。

- 请在实际使用以上命令时，将其中的“□”替换为“ ”。

###### 匹配换行

- 如果想要查找的内容之中包含换行符，那么可以使用"\n"通配符。执行以下命令，将匹配以"the"结尾的行，和以"word"开头的下一行：

  ```vim
  /the\nword
  ```

- 如果希望同时匹配包含换行，以及不包含换行（但包含一个空格）的"the word"，那么可以使用"\_s"匹配空格或换行：

  ```vim
  /the\_sword
  ```

- 如果希望同时匹配包含多个空格以及换行的"the word"，那么可以使用"+"通配符来匹配一次或多次：

  ```vim
  /the\_s\+word
  ```

![](https://pic2.zhimg.com/80/v2-131e63513559a6b544b28ba54df1cb19_720w.png)

###### 匹配单复数

- 将单数单词，替换为复数：

  ```vim
  :%s/^Note[□:s]*/Notes:□/g
  ```

  - 其中，"Note[□:s]"将匹配"Note□","Notes", 和"Note:"；而星号则会匹配零个后缀，即"Note"。

![](https://pic1.zhimg.com/80/v2-e5c05d1f89f2c686c316984b79a537e0_720w.jpg)

###### 匹配包围的字符串

- 匹配引号包围的字符串（包含换行）：

  ```vim
  "\_[^"]*"
  ```

- 匹配特定单词包围的字符串（包含换行）：

  ```vim
  \(we\).*\1
  ```

  - 其中，"\(we\)"将指定单词捕获为组，然后使用"\1"反向引用捕获组，以定义字符串的边界。

  ![](https://pic2.zhimg.com/80/v2-30fb38245a51c0457b5c0c28c756c809_720w.jpg)

###### 匹配章节编号

- 删除下图中黄色高亮区域，即行头以点分隔的章节号：

  ```vim
  :%s/^[1-9][0-9]*\.[1-9][0-9.]*□//
  ```

![](https://pic4.zhimg.com/80/v2-547711014812fd8c944384cfacf1ccc7_720w.jpg)

- 其中，模式末尾的"[0-9.]*"可以继续匹配更多层级的章节号。

###### 匹配序列号

- 匹配最少3个字符，最多16个字符，由字母和数字组成的用户名：

  ```vim
  ^[a-zA-Z0-9_-]{3,16}$
  ```

- 查找类似“1MGU103”的序列号。即由1个数字，3个大写字符和3个数字组成的字符串。可以使用以下几种不同的模式：

  ```
  [0-9][A-Z]{3}[0-9]{3}
  
  \d\u{3}\d{3}
  
  \d\u\u\u\d\d\d
  
  [[:digit:]][[:upper:]]{3}[[:digit:]]{3}
  ```

  - 其中：
    - "[0-9]"，"\d"，"[:digit:]"，均可匹配数字；
    - "[A-Z]"，"\u"，"[:upper:]"，均可匹配大写字母；
    - "{3}"，用于精确匹配3次。
    - 请注意，以上表达式均采用[Very Magic](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vim-Regex-VeryMagic.html)模式。

###### 匹配IP地址

- 匹配IPv4网络地址。即从"0.0.0.0"到"999.999.999.999"范围内的，以点分割的四段数字。

  ```vim
  /\v([0-9]{1,3}[\.]){3}[0-9]{1,3}
  ```

  - 但是以上命令，并不会判断数字串是否是一个有效的IP地址。比如"256.60.124.136"也会被匹配。但有效的IP地址中，每段数字均应为"0-255"。

- 匹配有效的IP地址。

  ```vim
  /\v(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
  ```

![](https://pic1.zhimg.com/80/v2-7451495aea16c54c40413a32c7edb478_720w.png)

- 以上表达式分为四段重复的[捕获组](https://link.zhihu.com/?target=http%3A//yyq123.github.io/learn-vim/learn-vim-Regex-Groups.html)，每组数字的范围如下图所示：

  ![](https://pic2.zhimg.com/80/v2-1d32a1faf088aed8b568bac8157ded91_720w.jpg)

### 脚本

##### 脚本语句

###### 判断

- if语句的一般形式如下：

  ```vim
  if condition
  	code_to_execute_if_condition_is_met
  endif
  ```

  - 只有条件(condition)为真时，if语句块内的语句才会被执行。

- if语句还可以包含else子句：

  ```vim
  if condition
  	code_to_execute_if_condition_is_true
  else
  	code_to_execute_if_condition_is_NOT_true
  endif
  ```

- if-else结构还可以进行多重判断

  ```vim
  if condition1
  	code_to_execute_if_condition1_is_true
  else
  	if condition2
  		code_to_execute_if_condition2_is_true
  	endif
  endif
  ```

###### 循环

- while命令开始一个循环，并由endwhile命令结束。在条件为真是，循环中的代码将被重复执行。

  ```vim
  let x=0
  while x <= 5
  	echo "x is now " x
  	let x+=1
  endwhile
  ```

  - continue命令回到程序的顶部开始执行下一次循环；而break命令则立刻退出循环。

    ```vim
    while conter < 30
    	if skip_flag
    		continue
    	endif
    	if exit_flag
    		break
    	endif
    endwhile
    ```

###### execute

- :execute将执行参数中指定的命令：

  ```vim
  :let command = " echo 'Hello world!'"
  :execute command
  
  Hello world
  ```

##### 变量

- &放在选项前面，表示选项变量，就是我们set设置的那些选项。

- Vim使用特殊的前缀来指明不同的变量类型：

  ![](https://pic3.zhimg.com/80/v2-a51007572723f11b2333d423b3afc5b6_1440w.png)

##### 自定义命令

- Vim编辑器允许定义自己的命令，我们可以像执行内置命令一样来执行我们自己定义的命令。
- call是用来调用我们自己定义的函数的，command自定义命令可以让我们定义一个自己的命令，这个命令用来执行call函数命令，这样我们就定义了一个自己的命令来使用call函数，这样更简单且方便。

###### 自定义命令

- 使用以下:command命令自定义命令：

  ```vim
  :command Delete_first :1delete
  ```

  - 注意自定义命令的名称，必须以大写字母开头，而且不能包含下划线；如果我们执行:Delete_first自定义命令，那么Vim就会执行:1delete命令，从而删除第一行。

- 可以使用!来强制重新定义同名的自定义命令：

  ```text
  :command! -nargs=+ Say :echo <args>
  ```

- 用户定义的命令可以指定一系列的参数，参数的个数由-nargs选项在命令行中指定。例如定义Delete_one命令没有参数：

  ```vim
  :command Delete_one -nargs=0 1delete
  ```

- 默认情况下-nargs=0，所以可以省略。其他-nargs选项值如下：

  ```
  -nargs=0 没有参数
  
  -nargs=1 1个参数
  
  -nargs=* 任何个数的参数
  
  -nargs=? 零个或是一个参数
  
  -nargs=+ 一个或是更多个参数
  ```

- 在命令定义中，参数是由关键字<args>指定的：

  ```text
  :command -nargs=+ Say :echo "<args>"
  ```

- 输入以下自定义命令：

  ```vim
  :Say Hello World
  ```

  - 命令的执行结果显示：

  ```text
  Hello World
  ```

- 使用-range选项，可以指定一个范围作为自定义命令的参数。-range选项值如下：

  ```
  -range允许范围，默认为当前行
  
  -range=%允许范围，默认为当前文件(while file)
  
  -range=count允许范围，单一的数字
  
  当指定范围之后，就可以用关键字<line1>和<line2>得到这个范围的第一行和最后一行。
  ```

- 例如以下定义了SaveIt命令，用于将指定范围的文件写入文件save_file：

  ```vim
  :command -range=% SaveIt :<line1>,<line2>write! save_file
  ```

- 关键字<f-args>含有与关键字<args>相同的信息，所不同的是它用于调用函数。例如以下自定义命令：

  ```text
  :command -nargs=* DoIt :call AFunction(<f-args>)
  ```

  - 执行自定义命令：

    ```vim
    :DoIt a b c
    ```

  - 将会传递参数给调用的函数：

    ```vim
    :call AFunction("a","b","c")
    ```

- 其他选项和关键字包括：

  ```
  -count=number指定数量保存在关键字<count>中
  
  -bang指定!修饰符存放在关键字<bang>中
  
  -register指定寄存器，默认为未命名寄存器，寄存器的定义保存在关键字<register>中
  
  -bar其他命令可以用|跟随在此命令之后
  
  -buffer命令仅对当前缓冲区有效
  ```

- 使用以下命令，首先分别创建一个用户自定义命令，然后再将两个命令组合起来。

  ```vim
  command! -bar DelTab %s/	//
  command! DelLF %s/\n//
  command! FmtCode DelTab|DelLF
  ```

- 使用以下命令，可以列出用户定义的命令：

  ```vim
  :command
  ```

- 使用以下:delcommand命令，可以删除用户定义的命令：

  ```vim
  :delcommand Delete_one
  ```

- 使用以下命令，清除所有的用户定义的命令：

  ```vim
  :comclear
  ```

## vim插件

#### coc-nvim

- CocList自带fuzzy模糊匹配，我们可以在里面进行搜索，wildmenu和CocList没有关系
- 如果我们使用CocCommand来查看命令按tap就是我们匹配的那些命令此时只能使用tap来选择或者手打，如果使用coclist commands来查看就是可以模糊匹配这些命令，此时就可以输入关键字来匹配。

##### coc extensions和lsp server

###### LSP

- **LSP**(Language Server Protocol) 语言服务协议，此协议定义了在编辑器或IDE与语言服务器之间使用的协议，该语言服务器提供了例如自动补全，转到定义，查找所有引用等的功能

  - LSP工作原理为c/s架构，IDE作为前端提供请求，语言服务器作为后端提供服务，这是两个进程，LSP定义了进程间通信的一些具体的协议，只要按照这个协议实现，语言服务器可以用任何语言来写，这样就大大简化了IDE提供服务的过程，不用重新编写接口来实现了，直接使用LSP来编写一套就可以直接在各个IDE中使用了。

  - 一些编译器例如clangd就具有语言服务器的功能，在使用语言服务器的时候我们需要安装这些编辑器

    ```
    "languageserver": {
      "clangd": {
        "command": "clangd",
        "rootPatterns": ["compile_flags.txt", "compile_commands.json"],
        "filetypes": ["c", "cc", "cpp", "c++", "objc", "objcpp"]
      }
    }
    ```

    - 使用语言服务器的时候，配置时的命令clangd表示那个编译器什么的，这个要在你的PATH环境变量里面。使用which clangd能看到。语言服务器本来就是一个进程，是一个elf文件，所以在使用的时候那个command选项就是那个进程的名字，也即是我们安装的语言服务器的名字。有一些编译器自带了语言服务器的功能，所以写上编译器的名字就可以了，但是有一些语言服务器需要我们自己编译安装，此时需要按照github上手册自己安装，然后放到PATH路径里面，command写上名字即可。

  - 使用LSP的时候要注意一定要安装语言服务器，否则不能使用。

  - 在coc.nvim官网看[Configure language servers](https://github.com/neoclide/coc.nvim/wiki/Language-servers)，里面有各种语言的配置，但是里面有一些会让你尝试使用coc extensions，可以尝试安装coc extensions体系来补全，这样比较好一点。

    - 如果我们想找对应的语言是否支持，可以查看上面这个链接，这个链接是按语言来分类的，在这里就能看见ada

###### coc extensions

- coc还有另外一套自动补全的体系，叫做coc extensions

- 使用coc extensions的主要原因是为了获得更好的用户体验。社区提供的一些语言服务器的性能不如 VSCode 扩展。 Coc 扩展可以从 VSCode 扩展中派生出来，并且应该提供类似或更好的用户体验。

- 与配置的语言服务器相比，扩展允许更多功能。

  - 扩展可以贡献命令（比如 VSCode），你可以通过不同的方式使用 coc 命令：

    - 使用命令 :CocList commands 打开命令列表并选择您需要的一个。

    - 使用 :CocCommand 和 <tab> 来完成命令行。

    - An example config to use the custom command `Tsc` for `tsserver.watchBuild`:

      ```shell
      command! -nargs=0 Tsc    :CocCommand tsserver.watchBuild
      ```

  - Extensions can contribute properties to the schema `coc-settings.json`, like in VSCode you can write the configuration with completion and validation support when you have `coc-json` installed.扩展可以为模式 coc-settings.json 贡献属性，就像在 VSCode 中一样，当您安装 coc-json 时，您可以编写具有完成和验证支持的配置。

    - 类似于可以对这个扩展进行编写json文件进行配置。

  - Extensions can contribute json schemas (loaded by [coc-json](https://github.com/neoclide/coc-json))扩展可以贡献 json 模式（由 coc-json 加载）

  - Extensions can contribute snippets that can be loaded by [coc-snippets](https://github.com/neoclide/coc-snippets) extension.扩展可以贡献可以由 coc-snippets 扩展加载的片段。

- 因为有上面一些好处，主要的是可以使用一些coc命令，语言服务器没有这些功能。

- 有一些coc extensions会使用语言服务器来完成功能，相当于在语言服务器上包装了一层，增加了一些功能，对于这些扩展，我们需要安装语言服务器。还有一些是不需要语言服务器，直接使用扩展这个体系就能完成功能。

  - **[coc-clangd](https://github.com/clangd/coc-clangd)** for C/C++/Objective-C, use [clangd](https://clangd.github.io/)
    - 上图是coc-clangd扩展给出的例子，说明其要使用clangd来完成功能。
  - **[coc-json](https://github.com/neoclide/coc-json)** for `json`.
    - 上面这个扩展是不需要安装语言服务器的
  - 注意看官方的说明，因为有的需要有的不需要。

##### coc-snippets

```
" Use <C-j> for jump to next placeholder, it's default of coc.nvim
let g:coc_snippet_next = '<c-j>'

" Use <C-k> for jump to previous placeholder, it's default of coc.nvim
let g:coc_snippet_prev = '<c-k>'
```

- 代码片段会有几个占位符来进行我们主要代码的编写，我们使用<c-j>来跳转到下一个<c-k>跳转到上一个。
- 代码片段会在提示的语句后面加一个波浪号～，这个就是代表代码片段，如果我们选择就会展开。

###### snippets没有二级窗口提示的问题

- 二级窗口展示的是snippets中的注释中的内容，如果没有注释就不会显示二级窗口，可以修改snippets中的注释就可以显示二级窗口，可以按照我们自己想要的来展示。

- 为什么补全的时候一个显示二级窗口，一个不显示，因为vim-snippets插件里面有Ultisnippets目录和snippets目录，里面都有相同的补全，但是一个有注释一个没有，在按TAB键的时候，两个代码片段都显示出来，但是一个有二级窗口一个没有，snippets中的注释一般没有，需要我们自己写注释。

  - git上honza/vim-snippets里面包含许多写好的代码片段我们拿过来使用就可以了。

    ```
    snippets/*: snippets using snipMate format
    UltiSnips/*: snippets using UltiSnips format
    ```

  - 上面的代码片段使用的格式不同，但是coc-snippets都能在代码补全的时候显示出来，兼容上面两种格式。所以导致很多时候有好几个代码片段的展示，需要我们自己选择一下。

###### 代码片段语法

- [UltiSnips官方解释](https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt)

- [UltiSnips中文解释](https://github.com/Linfee/ultisnips-zh-doc/blob/master/doc/UltiSnips_zh.txt)

  - 上面链接中包含VISUAL的使用，官方解释如下
    - 要查看带有 ${VISUAL} 占位符的片段如何工作，请定义一个片段占位符，使用Vim的可视模式选择一些文本，然后按用于触发扩展片段的键（请参阅 g:UltiSnipsExpandTrigger）。这选定的文本被删除，您将进入插入模式。现在输入片段选项卡触发并按下键触发扩展。作为片段展开，先前选择的文本将打印在 ${VISUAL} 的位置 占位符。
      - 意思为先选择一些文本，然后按出发扩展片段的键，这些文本会被删除，然后在输入片段选项卡触发扩展，此时先前选中的文本就会直接显示在VISUAL里面替换。
      - 如果不这样做，我们还可以将VISUAL删除，此时按C-h可以删除，这时插件定义的，C-u是在插入模式下向前移动光标。
      - VISUAL本来就是选择模式，我们可以先进入可视模式，然后选择VISUAL单词之后，按C-g进入选择模式，此时输入文字就会替换VISUAL单词，但是这样就不如上面那个官方解释好用了。这个在错误的考虑下主要是考虑到要删除VISUAL这些字符然后替换到我们想要的文字，但是错误的设置backspace下不能删除，才导致这种解决办法。
        - 选择模式上面有介绍可以看。
      - 上面说的选择模式下删除文本是因为backspace设置的不对导致的，不能删除，现在修改后在插入模式下能删除了，vim下删除键正常了。也可以向上面那样弄，但是比较麻烦，这个删除之后重新写是可以的

- 两种格式都是用$1, $2这种数字来提示占位符的，我们可以按照这个顺序来书写，并且按C-j时会按照这个数字来跳转占位符，$0有点特殊，不论有多少插入点被定义，他总是在片段的最后一个插入点，如果没有定义$0，$0将默认的被定义在片段的末尾。

  - 为什么设置$0，因为我们不管设置多少个占位符，最后总是有一个末尾的，我们可以直接将$0定义为最后一个，这样snippets中其他的部分修改，也不会影响到最后一个占位符的地方。这只是一种方便的记忆。当前我们也可以不用$0，直接从1开始按数字递增也是可以的，但是$0这样设置带来了一些好处。

  - 为一个插入点设置默认值常常是有用的，默认值可能是变量值常用的部分，或者是一个词语或短语，提醒你这里应该插入什么，语法是

    ```
    ${1:value}
    ```

    

#### Vim-surround

- 插件对(), [], {}, <>, ‘’, “”，标记语言xml html 有效，其中xml中前后的标记用t代表

- Vim插件surround的命令在vim不同操作模式下有不同的操作命令

  - 命令行模式

    ```
    ds                删除一个配对符号 (delete a surrounding)
    cs                更改一个配对符号 (change a surrounding)
    ys                增加一个配对符号 (yank a surrounding)
    yS                在新的行增加一个配对符号并进行缩进
    yss               在整行增加一个配对符号
    ySs/Yss     		  在整行增加一个配对符号，配对符号单独成行并进行缩进
    ```

    - 在vim光标所在位置配合vim动作(motion, 如w向后一个单词)或文本对象(如iw)，可以实现非常强大的功能。

      例如 `ysW(` 会在当前光标所在单词的周围增加一个**()**配对，

    - ```
      'Hello world!'
      Now press cs'<q> to change it to
      <q>Hello world!</q>
      
      <q>Hello world!</q>
      To go full circle, press cst" to get
      "Hello world!"
      其中的xml标签用t表示，增加标签和修改标签直接写上标签名字即可，不用写t，标签是第一个操作符用写，修改成的不用写
      ```

    - 删除的ds命令不用写具体的文件对象，直接ds“就可以了

      ```
      单词周围加双引号：ysiw"
      单词周围加圆括号：ysiw(，左括号是带空格的
      单词周围加方括号：ysiw]，右括号不带空格
      以空格为分界加圆括号：ysiWb，这是不带空格的括号，大 B 代表不带空格的花括号
      从光标位置到字母 n 加 <span>：ysfn<span>
      从光标位置到字母 n 前面加 "：ystn"
      整行前后加 <div>：yss<div>
      ```
  
  - 可视化模式
  
    ```
    S               在整行增加一个配对符号，配对符号单独成行并进行缩进
    ```
  
    - Finally, let's try out visual mode. Press a capital V (for linewise visual mode) followed by `S<p class="important">`.
  
      ```
      <p class="important">
        <em>Hello</em> world!
      </p>
      ```
  
    - `v` 模式选中区域前后加 `"`：`v` 选中，大 `S`，`"`。这种情况不会换行
  
    - 大 `V` 模式选中区域前后加 `<div>`：大 `V` 选中，大 `S`，`<div>`。这种情况会换行，`div` 标签和内容一共占据 `3` 行。
  
    - 如果小v选中的需要换行的时候，按gS
  
      ```
      Hello world! =>
      Hello {
         world
      }!
      ```
  
      
  
  - 插入模式
  
    ```
    Ctrl + s                    增加一个配对符号
    Ctrl +s, Ctrl +s        在整行增加一个配对符号，配对符号单独成行并进行缩进
    ```
  

#### vim-gutentags

- If you want to force-disable Gutentags for a given project even though it does match one of the items in gutentags_project_root, create a file named ".notags" at the root of the project.
  - 如果您想强制禁用给定项目的 Gutentags，即使它确实如此匹配gutentags_project_root中的一项，创建一个名为项目根目录下的“.notags”。

## Tmux

- tmux官网说的主要使用
  - Protect running programs on a remote server from connection drops by running them inside tmux.通过在 tmux 中运行它们来保护远程服务器上正在运行的程序免受连接中断的影响。
  - Allow programs running on a remote server to be accessed from multiple different local computers.允许从多个不同的本地计算机访问远程服务器上运行的程序。意思是我们可以换一个电脑来连接
  - Work with multiple programs and shells together in one terminal, a bit like a window manager.在一个终端中同时处理多个程序和 shell，有点像窗口管理器。

#### Tmux作用

- 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称"窗口"），在里面输入命令。用户与计算机的这种临时的交互，称为一次"会话"（session） 。
- 会话的一个重要特点是，窗口与其中启动的进程是[连在一起](https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。
- 一个典型的例子就是，[SSH 登录](https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。
- 为了解决这个问题，会话与窗口可以"解绑"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话"绑定"其他窗口。
- Tmux 就是会话与窗口的"解绑"工具，将它们彻底分离。
  - 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。
  - 它可以让新窗口"接入"已经存在的会话。
  - 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。
  - 它还支持窗口任意的垂直和水平拆分。
- Tmux 的最简操作流程
  - 新建会话`tmux new -s my_session`。
  - 在 Tmux 窗口运行所需的程序。
  - 按下快捷键`Ctrl+b d`将会话分离。
  - 下次使用时，重新连接到会话`tmux attach-session -t my_session`。

#### Tmux作用c语言

- tmux 是两个单词的缩写，即“Terminal MultipleXer”，意思是“终端复用器”
- 凡是互联网行业的从业者，无论是做运维的同学，还是做开发的同学，一般都是在自己的工作电脑上安装远程连接工具（如 iTerm、putty、XShell、SecureCRT 等），远程登录到公司服务器上，进行具体的操作，而其中一些操作的耗时会很长。
- 在这期间，一旦我们的远程连接工具所在的工作电脑出现断网或断电的情况，那么很多耗时较长的操作就会因此中断，这是所有运维、开发同学都很头疼的一个问题。下面，我们就先给大家列出一些典型的痛点。
  - 痛点一：大数据传输
    - 相信做过 Linux 服务运维的同学，都用 scp 进行过服务器间的大文件网络传输。一般这需要很长的时间，这期间，如果工作电脑出现断网或者断电的情况，则会导致远程连接工具无法与服务器通信，从而使得它所控制的数据传输也因此中断。
    - 有些同学说可以用 nohup 来解决啊，是的，这是一个办法，可是使用 nohup 的问题在于如果同时传输的任务众多，则最后你自己可能都分不清哪个任务对应哪个传输了，何况 nohup 还会留下 nohup.out 这么一个临时文件在那里。
    - 还有同学说，即使中断了，也可以断点续传啊。可惜的是，scp 并不支持断点续传。如果改用 rsync 倒是可以，可惜 rsync 参数用起来很是复杂，谁能保证每位运维工程师都能熟练掌握那么多复杂的参数呢？这个时候，请试一试 tmux 吧！
  - 痛点二：正在编译被拉去开会
    - 和大文件数据传输情况类似，一些大型的开发项目的代码编译过程，往往也需要很长的时间，短则几分钟，长则一通宵。对于一通宵的编译来说，这要是中间出现断网断电，那就相当悲剧了。整个项目进展就又要向后推迟至少一天。这个时候，我们向你推荐 tmux！
  - 痛点三：多个串口切换到晕
    - 作为运维工程师，一定有过在众多窗口间切换，查看各种服务器上的信息和状态的情况，这个时候，如果没有一款好用的窗口管理软件，过不了多久，你就会晕头转向了
  - 痛点四：一屏显示多窗口之殇
    - 有时候为了进行多文件内容对比，如果没有一款很好用的分屏管理工具，那么我们只好创建多个终端，然后手动调整它们的大小和位置，其实并不需要这么麻烦，tmux 可以帮助我们轻松分屏！
- 远程连接服务器的时候，假如这时候你要带着办公电脑去开会，你的电脑要断网，又不想中断服务器上正在执行的 watch 命令，怎么办呢？这时候可以使用detached分离，这表示，我们已经切断了办公电脑和刚才那个 tmux 之间的桥梁。现在如果你要外出，可以放心地关闭你的电脑了。当你回到家后，打开电脑，连接到你的那台远程服务器，然后执行一个神奇的命令：tmux attach -t重新连接会话，我们又回到了刚才的状态，那个查看内存使用状态的 watch 命令，在那里乖乖地运行着。这就是 tmux 的神奇之处，它可以让远端服务器的命令，脱离用户自己的电脑来执行，还可以随时召唤回来，继续进行操作和查看。
- 从这里看tmux可以用在服务器端，类似于上面，自己的电脑要断网的时候在服务器上执行tmux分离，然后连上网之后在重新连接会话就可以了，对于用户端来说主要就是作为会话的保存和记录以及多屏显示的功能。
- 因为我们远程连接服务器，也相当于是在服务器上开启了一个终端，也是在终端上执行命令，这时候我们就可以在服务器上安装一个tmux，然后通过在终端上执行tmux来保存分离会话，当我们自己的电脑断网之后我们就可以在次联网的时候远程连接到主机，因为还是那个服务器，我们就可以执行tmux 来重新连接会话。如果不是这样的话，每次我们远程连接都是一个全新的终端，以前的东西都不能记录和保存了。
- 以前理解的错误，将远程登录理解错了，以前将这种连接当成网络的连接了类似于C/S，但是这个tmux用的是ssh远程连接，然后相当于在一个终端上执行命令，此时就有了终端复用的概念，如果断网之后还可以重新连接，就不用重新弄，还可以用之前的会话。
- Tmuxs 是一款优秀的终端复用工具，使用它最直观的好处就是，通过一个终端登录远程主机并在远程主机上运行tmux后，在远程主机上可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。意思和上面类似，就是我们远程登录服务器之后，执行tmux命令，我们就可以在复用终端了，要不然需要重新连接重新登录，重新连接一个终端操作，这样很不方便。
- [tmux中ssh理解](http://louiszhai.github.io/2017/09/30/tmux/#%E5%AF%BC%E8%AF%BB)
  - 丝滑分屏（split），虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。
  - 上面说的ssh连接指的是在远程主机上运行tmux，然后在分屏，我们在本地就用一个终端连接就可以，远程主机上看每一个分屏就是一个连接，我们可以直接用，要不然还得一直在本地重新开终端，重新ssh连接。
    - 以前理解的错误，在本地打开tmux，然后ssh连接，在本地分屏，此时没有原有的ssh状态，以前觉得本地也能记录ssh连接，这是错误的，应该是远程主机上tmux分屏才能记录ssh连接。


#### Tmux重要概念

- 使用 Tmux 的时候千万不要去背指令，所有的指令都可以在 `.tmux.conf` 配置文件中绑定自己顺手的快捷键，也可以配置开启鼠标。这个是我的配置文件：https://github.com/zuorn/tmux.conf
- 在Tmux逻辑中，需要分清楚Server > Session > Window > Pane这个大小和层级顺序是极其重要的，直接关系到工作效率：
  - Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。
  - Session：是tmux的所有会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。
  - Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。
  - Pane：是在Window里面的小分屏。最常用也最好用

#### 常用操作指令及快捷键

```
# 查看有所有tmux会话
指  令：tmux ls
快捷键：Ctrl+b s

# 新建tmux窗口，重新命名，不用默认的名字
指  令：tmux new -s <session-name>

# 重命名会话
指  令：tmux rename-session -t <old-name> <new-name>
快捷键：Ctrl+b $

# 分离会话
指  令：tmux detach  或者使用  exit(关闭窗口)
快捷键：Ctrl+b d

# 重新连接会话
指  令：tmux attach -t <session-name>  或者使用 tmux at -t <session-name>

#平铺当前窗格（个人很喜欢的快捷键，注意：平铺的是当前选中的窗格）
快捷键：Ctrl+b z (再次 Ctrl+b z 则恢复)

# 杀死会话
指  令：tmux kill-session -t <session-name>

# 切换会话
指  令：tmux switch -t <session-name>

# 划分上下两个窗格
指  令：tmux split
快捷键：Ctrl+b “

# 划分左右两个窗格
指  令：tmux split -h
快捷键：Ctrl+b %

# 光标切换到上方窗格
指  令：tmux select-pane -U
快捷键：Ctrl+b 方向键上

# 光标切换到下方窗格
指  令：tmux select-pane -D
快捷键：Ctrl+b 方向键下

# 光标切换到左边窗格
指  令：tmux select-pane -L
快捷键：Ctrl+b 方向键左

# 光标切换到右边窗格
指  令：tmux select-pane -R
快捷键：Ctrl+b 方向键右

#关闭整个tmux服务器：
$ tmux kill-server
```

#### Tmux常用内部命令

- 所谓内部命令，就是进入Tmux后，并按下前缀键后的命令，一般前缀键为Ctrl+b. 虽然ctrl和b离得很远但是不建议改前缀键，因为别的键也不见得方便好记不冲突。还是记忆默认的比较可靠。

##### 系统操作

```
?	列出所有快捷键；按q返回
d	脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话
D	选择要脱离的会话；在同时开启了多个会话时使用
Ctrl+z	挂起当前会话
r	强制重绘未脱离的会话
s	选择并切换会话；在同时开启了多个会话时使用
:	进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器
[	进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出
]	粘贴复制模式中复制的文本
~	列出提示信息缓存；其中包含了之前tmux返回的各种提示信息
```

##### 窗口操作

```
c	创建新窗口
&	关闭当前窗口
数字键	切换至指定窗口
p	切换至上一窗口
n	切换至下一窗口
l	在前后两个窗口间互相切换
w	通过窗口列表切换窗口
,	重命名当前窗口；这样便于识别
.	修改当前窗口编号；相当于窗口重新排序
f	快速定位到窗口（输入关键字匹配窗口名称）
```

##### 面板操作

```
”	        将当前面板平分为上下两块
%	        将当前面板平分为左右两块
x	        关闭当前面板
z			平铺当前窗格（注意：平铺的是当前选中的窗格）(再次 Ctrl+b z 则恢复)
!	        将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板
Ctrl+方向键	以1个单元格为单位移动边缘以调整当前面板大小
Alt+方向键	以5个单元格为单位移动边缘以调整当前面板大小
Space	    在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、				tiled，意思是类似于vim中的水平和垂直切换窗口，按空格键就可以在水平和垂直切换。
q	        显示面板编号
o	        在当前窗口中选择下一面板
方向键	      移动光标以选择面板
{	        向前置换当前面板
}	        向后置换当前面板
Alt+o	    逆时针旋转当前窗口的面板
Ctrl+o	    顺时针旋转当前窗口的面板
```

#### 其他命令

```
# 列出所有快捷键，及其对应的 Tmux 命令
$ tmux list-keys

# 列出所有 Tmux 命令及其参数
$ tmux list-commands

# 列出当前所有 Tmux 会话的信息
$ tmux info

# 重新加载当前的 Tmux 配置
$ tmux source-file ~/.tmux.conf

# 在tmux.conf里加一句：
set -g mouse on 
```

#### Tmux配置

- [Tmux官方手册](https://github.com/tmux/tmux/wiki/Getting-Started)

##### Key bindings

- tmux key bindings are changed using the `bind-key` and `unbind-key` commands. Each key binding in tmux belongs to a named key table. There are four default key tables:

  - The `root` table contains key bindings for keys pressed without the prefix key.
  - The `prefix` table contains key bindings for keys pressed after the prefix key, like those mentioned so far in this document.
  - The `copy-mode` table contains key bindings for keys used in copy mode with *emacs(1)*-style keys.
  - The `copy-mode-vi` table contains key bindings for keys used in copy mode with *vi(1)*-style keys.

- All the key bindings or those for a single table can be listed with the `list-keys` command. By default, this shows the keys as a series of `bind-key` commands. The `-T` flag gives the key table to show and the `-N` flag shows the key help, like the `C-b ?` key binding.

  - For example to list only keys in the `prefix` table:

    ```
    $ tmux lsk -Tprefix
    bind-key    -T prefix C-b     send-prefix
    bind-key    -T prefix C-o     rotate-window
    ...
    
    $ tmux lsk -Tprefix -N
    C-b     Send the prefix key
    C-o     Rotate through the panes
    ...
    ```

- `bind-key` commands can be used to set a key binding, either interactively or most commonly from the configuration file. Like `list-keys`, `bind-key` has a `-T` flag for the key table to use. If `-T` is not given, the key is put in the `prefix` table; the `-n` flag is a shorthand for `-Troot` to use the `root` table.

- 上面的意思是说键可以映射到四个空间中，每一个空间都有特定的作用，我们可以使用-T来指定空间，如果不指定就是在prefix空间中，-n是在root空间中。

- 如果我们在不知道键映射具体的命令的时候可以使用上面的命令查看，然后在映射到其他的键上。

- 一般我们在看其他人的配置的时候都用的bind，其实bind就是bind-key的简写，功能都是一样的。`bind` 命令可以绑定多条命令，各命令间用 `\;` 分开，而key-bind一般是一条写一行。而且bind一般是省略-T来指定空间的，其一般都在prefix空间中

  ```
  bind r source-file ~/.tmux.conf \; display "Reloaded!"
  ```

- 我们在绑定键的时候会看到bind -r，这里的 `-r` 开关是 repeatable 可重复的意思，表示只需按一次 PREFIX, 后面可多次连续按绑定键。默认的间隔时间是 500 毫秒，可以设置 `repeat-time` 来修改。

  ```
  bind -r C-h select-window -t :-
  bind -r C-l select-window -t :+
  ```

  - 注意此处的-r是选项，上面的r是按键绑定

##### 会话和窗口的配置

- `set` 命令是针对会话的配置命令，而针对窗口的配置命令是 `set-window-option`，或者简写为 `setw`。由于窗格是窗口中的事物，要将窗格的默认编号也设置成从1 开始，应该用 `setw` 命令：

  ```
  setw -g pane-base-index 1
  ```

  - -g表示对所有的生效，包括窗口、pane、session等

## ranger

- 所有的快捷键都在rc.conf中有具体的映射规则，在我们不知道的时候直接打开文件看映射就可以了
- 配置文件
  - `ranger` uses 4 main configuration files:
    - `rc.conf` is used for setting various options and binding keys to functions.
    - `rifle.conf` decides which program to use for opening a file.
    - `scope.sh` is a shell script used to generate previews for various file types.
    - `commands.py` contains various functions' implementation, written in Python, used to modify `ranger's` behavior, and implement your own [Custom Commands](https://github.com/ranger/ranger/wiki/Custom-Commands).
  - rc.conf是各种快捷键的映射
  - rifle.conf是决定使用哪个程序打开文件。在一些编辑器的设置中，例如vim设置，文件浏览的设置都是在这个里面设置的。

##### 基础的快捷键

- `dU` 显示文件有多大
- `g` for navigation and tabs，一般快速切换目录都是先按g然后有导航条，然后进入到里面
- `F7`创建一个文件夹
- `zh`显示隐藏文件夹
- `o` for sort，排序，其中可以按大小，按时间排序什么的
- `/`类似于vim中的搜索，可以在当前目录下面快速跳转到一些文件下，n和N和vim下一样跳转到下一个和上一个
-  `i` display_file，用来全屏预览文件，然后在按一次就会退出。
- `r` for :open_with command，表示以什么命令打开文件，可以用python来运行文件，用默认的编辑器来打开等，可以输入数字选择
- `map ] move_parent 1; map [ move_parent -1`左右中括号表示在父文件夹中移动，就不用先移动到父文件夹在移动。
- `map H history_go -1; map L history_go 1`H和L表示在历史移动文件夹记录中移动文件夹。
- `y`用来复制一些东西yp表示复制文件的路径，yn复制文件名，这些在按y之后都有导航提示。
- `S`在ranger中进入到一些目录中，此时我们想退出ranger在终端中进入ranger的那个文件夹，此时我们按大写的S就可以进入到目录中

##### 一些映射

```
map :  console                                                                                               map ;  console                                                                                               map !  console shell%space                                                                                   map @  console -p6 shell  %%s                                                                               map #  console shell -p%space                                                                               map s  console shell%space                                                                                   map r  chain draw_possible_programs; console open_with%space                                                 map f  console find%space                                                                                   map cd console cd%space
```

- 上面这些都是默认的配置，在~/.config/ranger/rc.conf中

- console表示进入到ranger的命令行，后面的shell表示一个shell命令%space会打出来一个空格，直接在后面输入命令就可以。

  - 例如用vim创建一个文件就可以这样映射

    ```
    map V console shell vim%space
    ```

    - 这样按V的时候就可以输入文件名直接创建一个文件。

```
map cw console rename%space                                                                                 map a  rename_append                                                                                         map A  eval fm.open_console('rename ' + fm.thisfile.relative_path.replace("%", "%%"))                       map I  eval fm.open_console('rename ' + fm.thisfile.relative_path.replace("%", "%%"), position=7)
```

- 上面这组映射是重命名文件名的一组映射，cw是重新命名，a表示在原有的名字上加一些东西，其他的类似

```
# Tagging / Marking                                                                                         map t       tag_toggle                                                                                       map ut      tag_remove                                                                                       map "<any>  tag_toggle tag=%any                                                                             map <Space> mark_files toggle=True                                                                           map v       mark_files all=True toggle=True                                                             
map uv      mark_files all=True val=False                                                                   map V       toggle_visual_mode                                                                           
map uV      toggle_visual_mode reverse=True
```

- 空格键表示为选中文件，在按一次表示取消选中文件。v表示全部选中，选中之后我们可以进行一些操作，例如压缩文件。

##### 一些功能

- bulkrename
  - `ranger` supports bulk file renaming with the `:bulkrename` command. Mark the files that you want to rename and call `:bulkrename`. It should open a file containing a list of these files in your text editor (determined with `rifle`). You may freely change the names in that file. When you are done, save the file and close the editor. `ranger` will show you a preview of what will happen in a few moments.
  - ranger 支持使用 :bulkrename 命令批量文件重命名。标记要重命名的文件并调用 :bulkrename。它应该在您的文本编辑器中打开一个包含这些文件列表的文件（由ranger确定）。您可以自由更改该文件中的名称。完成后，保存文件并关闭编辑器。 ranger 将向您展示稍后将发生的事情的预览。
  - 上面说的意思是我们可以选中文件，用空格选中或者v全选什么的，然后输入：bulkrename，然后这些文件名会进入到文本编辑器中，我们可以在vim中很方便的修改一些文件名，然后退出就会全部修改了。当然bulkrename也可以映射，但是官方配置文件中没有映射。
- 压缩和解压缩
- 任务管理器
- 下载youtobe视频

##### ranger配置

- ranger --copy-config=all，生成默认的配置文件。
- set vcs_aware true，设置为true表示可以让git的文件修改与否的状态以文件后面的图标显示出来
- fzf的配置和映射，以脚本的形式。先在command.py中写入官方给的脚本，然后在rc.conf中配置一下键映射。
- 图标的配置，以插件的形式安装。在git上ranger仓库中的wiki都有说明
- 图片的预览

## curl

- curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。
- Curl 是一个常用的命令行数据传输工具，可以方便的从命令行创建网络请求。它支持众多协议，支持如 HTTP, HTTPS, FTP, FTPS, SFTP, IMAP, SMTP, POP3 等等协议。Curl 提供了很多强大的功能，我们可以利用它来进行 HTTP 请求、上传/下载文件等，且支持 Cookie、用户密码验证、代理隧道、限速等。
- Curl 用于上传和下载指定 URL 的数据，它是一个客户端(client-side)工具，一个客户端 URL 工具。这也是它的名字的由来。

##### 发起一个http get请求

- 当使用 curl 命令直接访问一个网址时，将发起一个 GET 请求，然后返回响应体。

  ```bash
  curl https://www.liuxing.io
  ```

  - 在命令行运行以上命令将返回，所访问[liuxing.io](https://www.liuxing.io/)页面源码。
  - 如果不加任何参数，将输出到标准输出即屏幕上。

##### 重定向跟踪

- `-L`参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。

- 当请求一个 URL 返回 301 之类的重定向响应时，可以使用 `-L` 参数来自动重定向跟踪响应头里的`Location`时。

  ```bash
  curl liuxing.io
  ```

- 在该网址设置了 301 重定向到 https 版 [https://www.liuxing.io](https://www.liuxing.io/) 。上面的示例不会自动完成重定向追踪。但我们可以使用以下命令：

  ```bash
  curl -L liuxing.io
  ```

##### 储存响应到文件

- `-o`参数将服务器的回应保存成文件，等同于`wget`命令。

- `-O`参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。

- 使用`-o`参数指定文件名，可以将响应结果储存到文件中

  ```bash
  curl -o liuxing.io.html https://www.liuxing.io
  ```

- 还可以使用`-O`参数直接用服务器上的文件名保存在本地

  ```javascript
  curl -O https://www.liuxing.io/index.html
  ```

  - 此时文件名是index.html

##### 静默输出

- -f选项说明，（HTTP）在服务器错误时静默失败（根本没有输出）。 这主要是为了使脚本等能够更好地处理失败的尝试。 在正常情况下，当 HTTP 服务器无法传递文档时，它会返回一个 HTML 文档来说明这一点（通常还描述了原因等等）。 该标志将阻止 curl 输出并返回错误 22。
- -f (--fail) 表示在服务器错误时，阻止一个返回的表示错误原因的 html 页面，而由 curl 命令返回一个错误码 22 来提示错误，-f选项阻止了上面说的HTML文档

##### 安静模式

- ```
  -S, --show-error
                When used with -s, --silent, it makes curl show an error message
                if it fails.
  -s, --silent
                Silent or quiet mode. Don't show progress meter or error messages.
                Makes Curl mute. It will still output the data you ask for,
                potentially even to the terminal/stdout unless you redirect it.
  
                Use -S, --show-error in addition to this option to disable
                progress meter but still show error messages.
  ```

  - -s选项是静音模式，只是不输出进度表和错误信息，正常的信息还是会显示的
  - -S选项是显示错误信息，这连个选项放在一起就是不显示进度表，但是显示错误信息。

#### raw.githubusercontent.com

- raw.githubusercontent.com是github用来存储用户上传的文件的服务地址，避免和主服务器抢占资源，两者除了最开始的位置，后面的文件夹路径都一样。

- 一般情况下我们访问的是github.com，但是这个网站上有一些其他的东西，网页的显示也是代码，所以这个页面上有一些其他的东西我们是不需要的，例如我们用curl下载时，如果这个页面有其他的东西，我们只是想要其中的代码，然后用-o选项保存成文件的时候就会出错。github网站给我们提供了解决办法，在github仓库中，我们点进去一个git仓库，例如vim-plug，此时我们会看到里面有一个plug.vim的源码，点进去我们看到和页面没什么区别，此时如果我们用curl下载就会有许多没用的东西，所以我们点击raw按钮，此时页面就会改变为没有其他的东西，只有我们想要的代码，此时上方的导航栏上面就是raw.githubusercontent.com，此时我们可以用curl下载，然后用-o选项保存到文件中，这样这个文件只有我们想要的代码。

  ```
  curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
      https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
      
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  ```

#### DNS污染和DNS劫持

##### DNS污染

- **网域服务器缓存污染**（DNS cache pollution），又称**域名服务器缓存投毒**（DNS cache poisoning），是指一些刻意制造或无意中制造出来的[域名服务器](https://baike.baidu.com/item/域名服务器/9705133)[数据包](https://baike.baidu.com/item/数据包)，把域名指往不正确的IP地址。一般来说，在[互联网](https://baike.baidu.com/item/互联网)上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。

- 某些国家或地区出于某些目的为了防止某网站被访问，而且其又掌握部分国际DNS根[目录服务器](https://baike.baidu.com/item/目录服务器/7750458)或镜像，也会利用此方法进行屏蔽。

- 原理解析
  - 我们假设A为用户端，B为DNS服务器，C为A到B链路的一个节点的网络设备（路由器，交换机，网关等等）。然后我们来模拟一次被污染的DNS请求过程。
  - A向B构建[UDP](https://baike.baidu.com/item/UDP)连接，然后，A向B发送查询请求，查询请求内容通常是：“A baidu.com”，这一个数据包经过节点设备C继续前往[DNS服务器](https://baike.baidu.com/item/DNS服务器/8079460)B；然而在这个过程中，C通过对数据包进行特征分析（远程通讯端口为DNS服务器端口，激发内容关键字检查，检查特定的域名如上述的“baidu.com",以及查询的记录类型"[A记录](https://baike.baidu.com/item/A记录)"），从而立刻返回一个错误的解析结果（如返回了"A 123.123.123.123"），众所周知，作为链路上的一个节点，C机器的这个结果必定会先于真正的域名服务器的返回结果到达用户机器A，而我们的DNS解析机制有一个重要的原则，就是只认第一，因此C节点所返回的查询结果就被A机器当作了最终返回结果，用于构建链接。

- 防除方法
  - 对于DNS污染，一般除了使用[代理服务器](https://baike.baidu.com/item/代理服务器)和[VPN](https://baike.baidu.com/item/VPN)之类的软件之外，并没有什么其它办法。但是利用我们对DNS污染的了解，还是可以做到不用代理服务器和VPN之类的软件就能解决DNS污染的问题，从而在不使用代理服务器或VPN的情况下访问原本访问不了的一些网站。当然这无法解决所有问题，当一些无法访问的网站本身并不是由DNS污染问题导致的时候，还是需要使用代理服务器或VPN才能访问的

  - DNS污染的数据包并不是在网络数据包经过的[路由器](https://baike.baidu.com/item/路由器)上，而是在其旁路产生的。所以DNS污染并无法阻止正确的DNS解析结果返回，但由于旁路产生的数据包发回的速度较国外[DNS服务器](https://baike.baidu.com/item/DNS服务器)发回的快，操作系统认为第一个收到的数据包就是返回结果，从而忽略其后收到的数据包，从而使得DNS污染得逞。而某些国家的DNS污染在一段时期内的污染IP却是固定不变的，从而可以忽略返回结果是这些IP地址的数据包，直接解决DNS污染的问题。

  - 修改[hosts](https://baike.baidu.com/item/hosts)文件，操作系统中[Hosts文件](https://baike.baidu.com/item/Hosts文件)的权限优先级高于DNS服务器，操作系统在访问某个域名时，会先检测HOSTS文件，然后再查询DNS服务器。可以在[hosts](https://baike.baidu.com/item/hosts)添加受到污染的DNS地址来解决DNS污染和DNS劫持。

    - 修改/etc/hosts文件时不能加上www，这样会解析出错，例如

      ```
      140.82.113.4 github.com
      这种写法是正确的，如果写成www.github.com就错误了。
      ```


##### hosts文件

- hosts ——`the static table lookup for host name`（主机名查询静态表）。

- hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。

- 优先级 ： dns缓存 > hosts > dns服务

- hosts文件可以配置主机ip与对应的主机名。在局域网或者是万维网上，每台主机都有一个ip地址，它区分开每台主机，并可以根据ip进行通讯。但是Ip地址不符合人脑的记忆规律，因此出现了域名，例如www.baidu.com.在一个局域网中，每台机器都有一个主机名，用于区分主机，便于相互访问。

  ```
  ip地址 主机名/域名 （主机别名）
  ```

  - 主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应的ip
  - 域名通常在internet上使用，但是优先级低于hosts文件中内容，因此如果你不想使用internet上的域名解析，可以更改自己的hosts文件，加入自己的域名解析。

- 在做域名解析时，应该设置一个不带www的域名。这样，当用户使用不带www的域名时，可以正常访问你的网站。

  - 本质上
    - 一个是顶级域名，而www是二级域名，或者说是一个特殊的二级域名。
    - www.和不带www.的域名可以是完全两个不同的网站，我们在做域名解析时可以将他们指向完全不同的两个IP或者网站。但是实际使用过程中，我们一般是将一个域名同时做了www.和不带www.的域名解析，而且指向同一个站点，因此访问的时候用户是感觉不出来有什么不同。
    - 带www和不带www的域名对搜索引擎是同等的，你可以任意选择其中一个作为主域名。
  - seo层面
    - 在搜索引擎看来，带www和不带www的URL是不同的两个URL。使用站长工具查询网站时，用www.baidu.com和baidu.com的结果是不一样的。
    - 有无www，对SEO绝对没有影响。甚至Google都说这完全是您的个人喜好。重要的是，您必须始终保持相同的选择，不要随便在网站上添加或删除www。您可以让Google知道您的个人喜好，Google会尊重您的选择。

##### DNS劫持

- [域名](https://baike.baidu.com/item/域名)劫持就是在劫持的网络范围内拦截[域名解析](https://baike.baidu.com/item/域名解析)的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。
- 由于[域名](https://baike.baidu.com/item/域名)劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的[域名服务器](https://baike.baidu.com/item/域名服务器)(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的[域名服务器](https://baike.baidu.com/item/域名服务器)以实现对网址的正常访问。所以[域名](https://baike.baidu.com/item/域名)劫持通常相伴的措施——封锁正常[DNS](https://baike.baidu.com/item/DNS)的[IP](https://baike.baidu.com/item/IP)。域名劫持只是在其可控制的范围内先解析域名然后在处理，如果这个解析过程就不经过他，我们就可以避过域名劫持，例如国内的DNS服务器被墙，我们可以设置国外的DNS，这样就避过了域名劫持
- 如果知道该[域名](https://baike.baidu.com/item/域名)的真实IP地址，则可以直接用此IP代替域名后进行访问。比如访问谷歌 ，可以把访问改为http://216.239.53.99/ ，从而绕开[域名](https://baike.baidu.com/item/域名)劫持。

#### curl通过翻墙不能访问github的原因

- 正常情况下被墙的一些地址被DNS污染了之后，我们只要通过代理服务器翻墙之类的操作即可以正常访问，因为其加密了我们访问的信息，所以GFW就不知道我们真正要访问那个地址，所以都放过了，我们就能访问了。但是curl不能正常访问我们需要的网址。其不能访问说明其没有走代理，即使在设置了代理的情况下

- 目前来看因为curl能自己配置代理，我们可以使用-x选项或者--proxy选项来设置curl的代理来访问。

- 因为hosts文件能解决，目前就是直接修改host文件来让curl访问被DNS污染的网址。

- 现在找到具体原因了，curl通过设置代理不能访问被墙的地址

  - curl走的是http和https协议，但是我们的代理设置的为socks5，这样就导致代理设置的不对，所以我们设置协议为http协议就可以了。
  - 即使是设置http_proxy和https_proxy，但是mac下在系统设置里面是有具体的端口设置的，不能都设置为1089，因为这两个代理的端口设置的为8889，所以导致前面测试不成功，后来设置这两个环境变量的代理，测试成功了，即使没有hosts文件修改的情况下。证明了代理是正确的可用的，只是前面设置的不对导致的。查看网络可以用netstat查看端口

- 在代理设置时，前面的表示协议类型

  ```
  export http_proxy=http://127.0.0.1:8889
  export https_proxy=http://127.0.0.1:8889
  export all_proxy=socks5://127.0.0.1:1089
  ```

  - 其中http和socks5代表协议类型，其也可以使用https协议，看自己设置，但是一般设置为http和socks
  - 其中all_proxy表示所有的流量都走协议的意思，所以我们也可以设置export all_proxy=http://127.0.0.1:8889，这样curl就能访问被墙的地址了，但是http协议本地监听端口是8889，要注意端口的对应。如果不设置all_proxy我们可以设置https_proxy和http_proxy来走http代理

## wget

- weget是Linux世界中最常用的网络下载工具，支持HTTP和FTP协议。

##### 常用命令

- 下载单个文件

  ```
  wget http://demo.com/demo.zip
  ```

- 下载多个文件

  ```
  将下载链接首先写在一个文本中，然后用wget -i url.txt来下载多个文件。假设我们有3个文件需要下载，这三个文件对应着三个链接，那么我们把这三个链接放在一个txt文件中。
  url.txt
  http://demo.com/demo1.zip
  https://demo.com/demo2.zip
  http://demo.com/demo3.zip
  ```

  - 那么我们在终端中运行

    ```
    wget -i url.txt
    ```

  - 有时候我们为了不让终端在下载的过程中回显任何信息可以加上 `-q`选项，该命令表示静默模式

    ```
    wget -i url.txt -q
    ```

- 断点续传

  ```
  wget -c http://demo.com/demo.zip
  ```

  - wget命令支持断点续传功能，只需要加上 `-c`选项即可

  - 当然如果遇到网络不好的情况，我们希望wget可以多尝试几次，可以通过`-t n`来设置，`n`表示尝试的次数，`n`取`0`时表示一直尝试。

    ```
    wget -c -t 10 http://demo.com/demo.zip
    ```

  - 我们有时可能需要对下载的文件重命名，可以使用`-O`选项

    ```
    wget http://demo.com/demo.zip -O demo.download.zip 
    ```

- 后台执行，有时需要wget下载在后台执行，可以添加 -b选项，这时执行该命令的回显信息都会自动存储在wget.log文件中

  ```
  wget -b http://demo.com/demo.zip
  ```

- 从FTP服务器上下载文件时一般需要输入用户名和密码

  ```
  wget --ftp-user username --ftp-password xxxx ftp://demo.com/demo.zip
  ```

  - http一般不用设置用户名和密码

- 上面这些命令在wget --help中都可以看到具体的命令是什么含义。

##### wget和curl区别

- wget 是一个独立的下载程序，无需额外的资源库，它也允许你下载网页中或是 FTP 目录中的任何内容, 能享受它超凡的下载速度，简单直接。
- curl是一个多功能工具，是libcurl这个库支持的。它可以下载网络内容，但同时它也能做更多别的事情。
- 从用途方面，wget倾向于网络文件下载；curl倾向于网络接口调试，相当于一个无图形界面的 PostMan 工具
- **curl命令**是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。
- **wget命令**用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。
- 我们可以将curl下载的东西输出到终端上，wget不行，所以我们可以用curl测试代理通不通curl google.com
- Curl可以post数据，可以自定义发送头，如cookie/浏览器信息等，可以上传文件，等等。同时还支持N多协议，Curl要比Wget强大很多.
- 所以在正常的下载时一般用wget就够用了，在其他一些更复杂的功能用curl。

## fzf

##### fzf官方文档说明

```
fzf project consists of the following components:

	-fzf executable
	-fzf-tmux script for launching fzf in a tmux pane
	-Shell extensions
		Key bindings (CTRL-T, CTRL-R, and ALT-C) (bash, zsh, fish)
        Fuzzy auto-completion (bash, zsh)
	-Vim/Neovim plugin
You can download fzf executable alone if you don't need the extra stuff.
Key bindings (CTRL-T / CTRL-R / ALT-C) and fuzzy auto-completion may not be enabled by default.
```

- 上面说明fzf安装完有四个组件，可以单独下载fzf可执行文件进行使用，用各种包管理器安装fzf后，上面四个组件都下载了，但是只有最基本的功能，其中Fuzzy auto-completion (bash, zsh)和key bindings没有进行扩展使用，所以我们需要进行额外的操作来让这两个功能正常。这样在bash或zsh中就能在命令行中使用`cd ** <tab> 或者 vim **<tab>`来使用。

##### mac

```
brew install fzf

# To install useful key bindings and fuzzy completion:
$(brew --prefix)/opt/fzf/install
```

- mac下安装完进行扩展功能的正常使用时，因为brew安装完，在安装包里面有个install脚本，我们直接执行这个脚本就可以了

##### linux

- linux可以使用各种包管理器进行安装例如`pacman -S fzf`，此时只是下载了基本的fzf可执行程序，需要我们进行额外的扩展进行操作。

- 使用命令查找fzf安装在哪里

  ```
  whereis fzf
  fzf: /usr/bin/fzf /usr/share/fzf /usr/share/man/man1/fzf.1.gz
  ```

- 可以看到fzf安装在`/usr/share/fzf`，里面有四个文件

  ```
  completion.bash  
  completion.zsh  
  key-bindings.bash  
  key-bindings.zsh
  ```

  - 分别为zsh和bash的键扩展和模糊补全功能

- 我们只需要将我们需要的放到相应的配置文件中就可以，例如将key-bindings.bash 和key-bindings.zsh放到.zshrc中就可以

  ```
  if [[ -e /usr/share/fzf ]]; then
      source /usr/share/fzf/completion.zsh
      source /usr/share/fzf/key-bindings.zsh
  fi
  ```

  - 相当于我们在启动zsh的时候就自动执行了这两个脚本，这样我们就可以使用扩展功能和键扩展了。

- 上面这是手动安装的，最简单的方法是下载git仓库，里面有一个安装脚本，直接执行就可以了，但是最后source的是仓库里面那两个文件，导致这个仓库不能删除，我们可以简单修改一下，然年将这个仓库删除


## cscope

- cscope是一个程序，功能类似于ctags，只适用于c,c++,java源码，功能比ctags强大，类似于ctags程序，cscope需要安装

- cscope作用

  ```
  Cscope is an interactive screen-oriented tool that helps you:
         Learn how a C program works without endless flipping through a thick
         listing.
         
         Locate the section of code to change to fix a bug without having to
         learn the entire program.
         
         Examine the effect of a proposed change such as adding a value to an
         enum variable.
  
         Verify that a change has been made in all source files such as adding
         an argument to an existing function.
  
         Rename a global variable in all source files.
         
         Change a constant to a preprocessor symbol in selected lines of files.
  ```

  ```
  It is designed to answer questions like:
         Where is this symbol used?
         Where is it defined?
         Where did this variable get its value?
         What is this global symbol's definition?
         Where is this function in the source files?
         What functions call this function?
         What functions are called by this function?
         Where does the message "out of space" come from?
         Where is this source file in the directory structure?
         What files include this header file?
  它旨在回答以下问题：
          这个符号在哪里使用？
          它在哪里定义？
          这个变量从哪里得到它的值？
          这个全局符号的定义是什么？
          这个函数在源文件中的什么位置？
          什么函数调用这个函数？
          这个函数调用了哪些函数？
          “空间不足”的信息从何而来？
          这个源文件在目录结构中的什么位置？
          哪些文件包含这个头文件？
  ```

- 如果是直接调用cscope来使用会得到一个全屏的选项，下面后写一堆来表示上面的问题，回答之后就会使用默认的文本编辑器编辑文件，此时就不能使用类似于tags文件的跳转功能了。

- vim下使用的cscope是用的cscope接口，此时我们可以使用类似于tags文件的跳转功能。下面介绍的都是cscope作为vim插件使用的。

- 所有 cscope 命令都通过主 cscope 的子选项访问命令“:cscope”。 最短的缩写是“:cs”。 ":scscope"命令做同样的事情，也分割窗口（简写：“scs”）。

- cs add

  ```
  add   : Add a new cscope database/connection.
  
          USAGE   :cs add {file|dir} [pre-path] [flags]
  
              [pre-path] is the pathname used with the -P command to cscope.
  
              [flags] are any additional flags you want to pass to cscope.
  
          EXAMPLES >
              :cscope add /usr/local/cdb/cscope.out
              :cscope add /projects/vim/cscope.out /usr/local/vim
              :cscope add cscope.out /usr/local/vim -C
  ```

  - 上面中的flag例如-C是cscope命令中的选项，可以通过man手册看到，-C是忽略大小写，表示在查找的时候忽略大小写。

  - 一些使用

    ```
    首先来分享一个小脚本，可以帮助我们在项目中生成cscope.out 和ctags。
    
    我把这个文件命名为cs.sh
    
    #!/bin/sh  
    find . -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.java"\  
            >cscope.files  
    cscope -bkq -i cscope.files  
    ctags -R  
    
    
    需要的注意的是，上面的脚本中，生成的cscope.files中保存的是相对路径，而不是绝对路径。这样的话，在cscope 中查找tags的时候，是没法打开相应的包含查找结果的文件的。怎么避免这个问题呢？有如下两个方法：
    
    1， 在cs.sh的脚本中，find命令后接一个变量PRO_PATH，这个PRO_PATH是当前项目的跟目录，这个时候cscope.files中保存的就是所有项目文件的绝对路径了。
    
    2，在:cs add的时候，接一个prepend path
    
    :cs add [cscope.out] [pre-path]  
    
    我用了第二个方法，所以就有了下面的vimrc片段，
    
    if has("cscope")  
        set csprg=/usr/bin/cscope  
        set csto=0  
        set cst  
        set csverb  
        set cspc=3  
        "add any database in current dir  
        if filereadable("cscope.out")  
            cs add cscope.out  
        "else search cscope.out elsewhere  
        else  
           let cscope_file=findfile("cscope.out", ".;")  
           let cscope_pre=matchstr(cscope_file, ".*/")  
           if !empty(cscope_file) && filereadable(cscope_file)  
               exe "cs add" cscope_file cscope_pre  
           endif        
         endif  
    endif  
    ```

    

- cs find

  ```
  find  : Query cscope.  All cscope query options are available except option #5 ("Change this grep pattern").
  
          USAGE   :cs find {querytype} {name}
  
              {querytype} corresponds to the actual cscope line
              interface numbers as well as default nvi commands:
  
                  0 or s: Find this C symbol
                  1 or g: Find this definition
                  2 or d: Find functions called by this function
                  3 or c: Find functions calling this function
                  4 or t: Find this text string
                  6 or e: Find this egrep pattern
                  7 or f: Find this file
                  8 or i: Find files #including this file
  	For all types, except 4 and 6, leading white space for {name} is
          removed.  For 4 and 6 there is exactly one space between {querytype}
          and {name}.  Further white space is included in {name}.
  
  ```

  - 上面的意思是说除了4和6之外其他的name和querytype之间的空格都会被删掉当作一个，4和6如果有多余的空格会放到name中，当作name的一部分

- cs kill

  ```
  kill  : Kill a cscope connection (or kill all cscope connections).
  
              USAGE   :cs kill {num|partial_name}
  ```

  - 断掉这个连接，将cs add的cscope文件断掉

- cs reset ,cs show都是和连接有关

- cstag命令

  - 如果你使用 cscope 和 ctags，|:cstag| 允许您在跳转之前搜索其中一个。 例如，您可以选择首先在您的 cscope 数据库中搜索匹配项，如果没有找到，则将搜索您的标签文件。 这发生的顺序由|csto| 的值决定。 
  - |:cstag| 搜索 cscope 数据库时，对标识符执行等效的 ":cs find g"。
  - |:cstag| 相当于 |:tjump| 搜索标签文件时在标识符上。
  - 上面说明cstag命令在查找cscope文件时，执行的是cs find g命令，查找tags文件时，执行的是tjump命令。

##### cscope一些选项

-  cscopeprg    csprg

  ```
  'cscopeprg' specifies the command to execute cscope.  The default is "cscope".  For example: >
          :set csprg=/usr/local/bin/cscope
  ```

  - 上面说的是可以设置cscope可执行程序的路径，一般都在PATH里面不用设置。

- cscopetag    cst

  ```
  If 'cscopetag' set, the commands ":tag" and CTRL-] as well as "vim -t" will always use |:cstag| instead of the default :tag behavior.  Effectively, by setting 'cst', you will always search your cscope databases as well as your tag files.  The default is off.  Examples: >
          :set cst
          :set nocst
  ```

  - 上面的意思是说如果设置了cst，tag ，CTRL-] ，vim -t这三个命令将会使用cstag命令，而不是用默认的tag命令。cstag命令说明如上面。

- cscopetagorder   csto

  ```
  The value of 'csto' determines the order in which |:cstag| performs a search.If 'csto' is set to zero, cscope database(s) are searched first, followed by tag file(s) if cscope did not return any matches.  If 'csto' is set to one, tag file(s) are searched before cscope database(s).  The default is zero.
  Examples: >
          :set csto=0
          :set csto=1
  ```

  - 上面说的是如果同时使用ctags和cscope时，可以设置查找顺序，设置为0表示先查询cscope文件，设置为1先查询tags文件。

- cscopeverbose   csverb

  ```
  If 'cscopeverbose' is not set (the default), messages will not be printed indicating success or failure when adding a cscope database.  Ideally, you should reset this option in your |.vimrc| before adding any cscope databases, and after adding them, set it.  From then on, when you add more databases within Vim, you will get a (hopefully) useful message should the database fail to be added.  Examples: >
          :set csverb
          :set nocsverb
  ```

  - 上面表示如果设置了csverb在add cscope文件时会打印提示信息。

##### 官方建议vimrc

```
Put these entries in your .vimrc (adjust the pathname accordingly to your
setup): >

        if has("cscope")
                set csprg=/usr/local/bin/cscope
                set csto=0
                set cst
                set nocsverb
                " add any database in current directory
                if filereadable("cscope.out")
                    cs add cscope.out
                " else add database pointed to by environment
                elseif $CSCOPE_DB != ""
                    cs add $CSCOPE_DB
                endif
                set csverb
        endif
```

- 可以通过设置环境变量来改变添加的cscope文件

##### 键盘映射

- 通过help cscope可以看到官方介绍的一些键盘映射，包括水平分屏和垂直分屏以及直接跳转的。
- 通过设置cst可以将一些tag操作转换成cstag，但是我们也可以不设置，直接tag使用tag的命令，cscope文件使用cstag命令，或者不使用cstag命令，直接使用键盘映射cs find g这个命令，这样两个就区分开了。cstag只是给我们提供了一个途径更好的使用两种文件，但是我们也可以不用。

##### 生成cscope文件

- -b选项生成交叉引用文件，即数据库文件cscope.out，不会进入到交互界面

- -R递归选项。

- -q选项

  ```
  nable  fast  symbol lookup via an inverted index. This option causes cscope to create 2 more files (default names ``cscope.in.out'' and ``cscope.po.out'') in addition to the normal database.
                This allows a faster symbol search algorithm that provides noticeably faster lookup performance for large projects.
  ```

  - 会额外生成两个文件，查找速度更快。

- -f生成的cscope文件默认为cscope.out，可以使用-f选项修改名称。

- 还可以通过脚本生成

  ```
  find . -name "*.h" -o -name "*.c" -o -name "*.cpp" > cscope.files
  cscope -bkq -i cscope.files
  rm cscope.files
  ```

  - 先查找文件目录放到一个文件中，然后通过文件生成cscope，然后在删除
  - 这样不如cscope -Rb这样方便。
